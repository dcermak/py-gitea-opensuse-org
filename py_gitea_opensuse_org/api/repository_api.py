# coding: utf-8

"""
    Gitea API.

    This documentation describes the Gitea API.  # noqa: E501

    The version of the OpenAPI document: 1.19.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated
from typing import overload, Optional, Union, Awaitable

from datetime import datetime

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, conlist

from typing import Dict, List, Optional, Union

from py_gitea_opensuse_org.models.add_collaborator_option import AddCollaboratorOption
from py_gitea_opensuse_org.models.annotated_tag import AnnotatedTag
from py_gitea_opensuse_org.models.attachment import Attachment
from py_gitea_opensuse_org.models.branch import Branch
from py_gitea_opensuse_org.models.branch_protection import BranchProtection
from py_gitea_opensuse_org.models.changed_file import ChangedFile
from py_gitea_opensuse_org.models.combined_status import CombinedStatus
from py_gitea_opensuse_org.models.commit import Commit
from py_gitea_opensuse_org.models.commit_status import CommitStatus
from py_gitea_opensuse_org.models.contents_response import ContentsResponse
from py_gitea_opensuse_org.models.create_branch_protection_option import CreateBranchProtectionOption
from py_gitea_opensuse_org.models.create_branch_repo_option import CreateBranchRepoOption
from py_gitea_opensuse_org.models.create_file_options import CreateFileOptions
from py_gitea_opensuse_org.models.create_fork_option import CreateForkOption
from py_gitea_opensuse_org.models.create_hook_option import CreateHookOption
from py_gitea_opensuse_org.models.create_key_option import CreateKeyOption
from py_gitea_opensuse_org.models.create_pull_request_option import CreatePullRequestOption
from py_gitea_opensuse_org.models.create_pull_review_options import CreatePullReviewOptions
from py_gitea_opensuse_org.models.create_push_mirror_option import CreatePushMirrorOption
from py_gitea_opensuse_org.models.create_release_option import CreateReleaseOption
from py_gitea_opensuse_org.models.create_repo_option import CreateRepoOption
from py_gitea_opensuse_org.models.create_status_option import CreateStatusOption
from py_gitea_opensuse_org.models.create_tag_option import CreateTagOption
from py_gitea_opensuse_org.models.create_wiki_page_options import CreateWikiPageOptions
from py_gitea_opensuse_org.models.delete_file_options import DeleteFileOptions
from py_gitea_opensuse_org.models.deploy_key import DeployKey
from py_gitea_opensuse_org.models.dismiss_pull_review_options import DismissPullReviewOptions
from py_gitea_opensuse_org.models.edit_attachment_options import EditAttachmentOptions
from py_gitea_opensuse_org.models.edit_branch_protection_option import EditBranchProtectionOption
from py_gitea_opensuse_org.models.edit_git_hook_option import EditGitHookOption
from py_gitea_opensuse_org.models.edit_hook_option import EditHookOption
from py_gitea_opensuse_org.models.edit_pull_request_option import EditPullRequestOption
from py_gitea_opensuse_org.models.edit_release_option import EditReleaseOption
from py_gitea_opensuse_org.models.edit_repo_option import EditRepoOption
from py_gitea_opensuse_org.models.file_delete_response import FileDeleteResponse
from py_gitea_opensuse_org.models.file_response import FileResponse
from py_gitea_opensuse_org.models.generate_repo_option import GenerateRepoOption
from py_gitea_opensuse_org.models.git_blob_response import GitBlobResponse
from py_gitea_opensuse_org.models.git_hook import GitHook
from py_gitea_opensuse_org.models.git_tree_response import GitTreeResponse
from py_gitea_opensuse_org.models.hook import Hook
from py_gitea_opensuse_org.models.issue_template import IssueTemplate
from py_gitea_opensuse_org.models.merge_pull_request_option import MergePullRequestOption
from py_gitea_opensuse_org.models.migrate_repo_options import MigrateRepoOptions
from py_gitea_opensuse_org.models.note import Note
from py_gitea_opensuse_org.models.pull_request import PullRequest
from py_gitea_opensuse_org.models.pull_review import PullReview
from py_gitea_opensuse_org.models.pull_review_comment import PullReviewComment
from py_gitea_opensuse_org.models.pull_review_request_options import PullReviewRequestOptions
from py_gitea_opensuse_org.models.push_mirror import PushMirror
from py_gitea_opensuse_org.models.reference import Reference
from py_gitea_opensuse_org.models.release import Release
from py_gitea_opensuse_org.models.repo_collaborator_permission import RepoCollaboratorPermission
from py_gitea_opensuse_org.models.repo_topic_options import RepoTopicOptions
from py_gitea_opensuse_org.models.repository import Repository
from py_gitea_opensuse_org.models.search_results import SearchResults
from py_gitea_opensuse_org.models.submit_pull_review_options import SubmitPullReviewOptions
from py_gitea_opensuse_org.models.tag import Tag
from py_gitea_opensuse_org.models.team import Team
from py_gitea_opensuse_org.models.topic_name import TopicName
from py_gitea_opensuse_org.models.topic_response import TopicResponse
from py_gitea_opensuse_org.models.tracked_time import TrackedTime
from py_gitea_opensuse_org.models.transfer_repo_option import TransferRepoOption
from py_gitea_opensuse_org.models.update_file_options import UpdateFileOptions
from py_gitea_opensuse_org.models.user import User
from py_gitea_opensuse_org.models.watch_info import WatchInfo
from py_gitea_opensuse_org.models.wiki_commit_list import WikiCommitList
from py_gitea_opensuse_org.models.wiki_page import WikiPage
from py_gitea_opensuse_org.models.wiki_page_meta_data import WikiPageMetaData

from py_gitea_opensuse_org.api_client import ApiClient
from py_gitea_opensuse_org.api_response import ApiResponse
from py_gitea_opensuse_org.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class RepositoryApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @overload
    async def accept_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def accept_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def accept_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Accept a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.accept_repo_transfer(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the accept_repo_transfer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.accept_repo_transfer_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def accept_repo_transfer_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], **kwargs) -> ApiResponse:  # noqa: E501
        """Accept a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.accept_repo_transfer_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_repo_transfer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '202': "Repository",
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer/accept', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def create_current_user_repo(self, body : Optional[CreateRepoOption] = None, **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def create_current_user_repo(self, body : Optional[CreateRepoOption] = None, async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def create_current_user_repo(self, body : Optional[CreateRepoOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_current_user_repo(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_current_user_repo_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.create_current_user_repo_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def create_current_user_repo_with_http_info(self, body : Optional[CreateRepoOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_current_user_repo_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_current_user_repo" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Repository",
            '400': None,
            '409': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/user/repos', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def create_fork(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to fork")], repo : Annotated[StrictStr, Field(..., description="name of the repo to fork")], body : Optional[CreateForkOption] = None, **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def create_fork(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to fork")], repo : Annotated[StrictStr, Field(..., description="name of the repo to fork")], body : Optional[CreateForkOption] = None, async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def create_fork(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to fork")], repo : Annotated[StrictStr, Field(..., description="name of the repo to fork")], body : Optional[CreateForkOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Fork a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_fork(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to fork (required)
        :type owner: str
        :param repo: name of the repo to fork (required)
        :type repo: str
        :param body:
        :type body: CreateForkOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_fork_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.create_fork_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def create_fork_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to fork")], repo : Annotated[StrictStr, Field(..., description="name of the repo to fork")], body : Optional[CreateForkOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fork a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_fork_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to fork (required)
        :type owner: str
        :param repo: name of the repo to fork (required)
        :type repo: str
        :param body:
        :type body: CreateForkOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fork" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '202': "Repository",
            '403': None,
            '409': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/forks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def generate_repo(self, template_owner : Annotated[StrictStr, Field(..., description="name of the template repository owner")], template_repo : Annotated[StrictStr, Field(..., description="name of the template repository")], body : Optional[GenerateRepoOption] = None, **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def generate_repo(self, template_owner : Annotated[StrictStr, Field(..., description="name of the template repository owner")], template_repo : Annotated[StrictStr, Field(..., description="name of the template repository")], body : Optional[GenerateRepoOption] = None, async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def generate_repo(self, template_owner : Annotated[StrictStr, Field(..., description="name of the template repository owner")], template_repo : Annotated[StrictStr, Field(..., description="name of the template repository")], body : Optional[GenerateRepoOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Create a repository using a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.generate_repo(template_owner, template_repo, body, async_req=True)
        >>> result = thread.get()

        :param template_owner: name of the template repository owner (required)
        :type template_owner: str
        :param template_repo: name of the template repository (required)
        :type template_repo: str
        :param body:
        :type body: GenerateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the generate_repo_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.generate_repo_with_http_info(template_owner, template_repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def generate_repo_with_http_info(self, template_owner : Annotated[StrictStr, Field(..., description="name of the template repository owner")], template_repo : Annotated[StrictStr, Field(..., description="name of the template repository")], body : Optional[GenerateRepoOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a repository using a template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.generate_repo_with_http_info(template_owner, template_repo, body, async_req=True)
        >>> result = thread.get()

        :param template_owner: name of the template repository owner (required)
        :type template_owner: str
        :param template_repo: name of the template repository (required)
        :type template_repo: str
        :param body:
        :type body: GenerateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'template_owner',
            'template_repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_repo" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['template_owner']:
            _path_params['template_owner'] = _params['template_owner']

        if _params['template_repo']:
            _path_params['template_repo'] = _params['template_repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Repository",
            '403': None,
            '404': None,
            '409': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{template_owner}/{template_repo}/generate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_annotated_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.")], **kwargs) -> AnnotatedTag:  # noqa: E501
        ...

    @overload
    def get_annotated_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.")], async_req: Optional[bool]=True, **kwargs) -> AnnotatedTag:  # noqa: E501
        ...

    @validate_arguments
    def get_annotated_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.")], async_req: Optional[bool]=None, **kwargs) -> Union[AnnotatedTag, Awaitable[AnnotatedTag]]:  # noqa: E501
        """Gets the tag object of an annotated tag (not lightweight tags)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotated_tag(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AnnotatedTag
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_annotated_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_annotated_tag_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    @validate_arguments
    def get_annotated_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the tag object of an annotated tag (not lightweight tags)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotated_tag_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AnnotatedTag, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotated_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "AnnotatedTag",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/tags/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_blob(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], **kwargs) -> GitBlobResponse:  # noqa: E501
        ...

    @overload
    def get_blob(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], async_req: Optional[bool]=True, **kwargs) -> GitBlobResponse:  # noqa: E501
        ...

    @validate_arguments
    def get_blob(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], async_req: Optional[bool]=None, **kwargs) -> Union[GitBlobResponse, Awaitable[GitBlobResponse]]:  # noqa: E501
        """Gets the blob of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_blob(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_blob_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    @validate_arguments
    def get_blob_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the blob of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_blob_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "GitBlobResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/blobs/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_tree(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], recursive : Annotated[Optional[StrictBool], Field(description="show all directories and files")] = None, page : Annotated[Optional[StrictInt], Field(description="page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page")] = None, per_page : Annotated[Optional[StrictInt], Field(description="number of items per page")] = None, **kwargs) -> GitTreeResponse:  # noqa: E501
        ...

    @overload
    def get_tree(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], recursive : Annotated[Optional[StrictBool], Field(description="show all directories and files")] = None, page : Annotated[Optional[StrictInt], Field(description="page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page")] = None, per_page : Annotated[Optional[StrictInt], Field(description="number of items per page")] = None, async_req: Optional[bool]=True, **kwargs) -> GitTreeResponse:  # noqa: E501
        ...

    @validate_arguments
    def get_tree(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], recursive : Annotated[Optional[StrictBool], Field(description="show all directories and files")] = None, page : Annotated[Optional[StrictInt], Field(description="page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page")] = None, per_page : Annotated[Optional[StrictInt], Field(description="number of items per page")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[GitTreeResponse, Awaitable[GitTreeResponse]]:  # noqa: E501
        """Gets the tree of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tree(owner, repo, sha, recursive, page, per_page, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param recursive: show all directories and files
        :type recursive: bool
        :param page: page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
        :type page: int
        :param per_page: number of items per page
        :type per_page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitTreeResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_tree_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_tree_with_http_info(owner, repo, sha, recursive, page, per_page, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tree_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], recursive : Annotated[Optional[StrictBool], Field(description="show all directories and files")] = None, page : Annotated[Optional[StrictInt], Field(description="page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page")] = None, per_page : Annotated[Optional[StrictInt], Field(description="number of items per page")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the tree of a repository.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tree_with_http_info(owner, repo, sha, recursive, page, per_page, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param recursive: show all directories and files
        :type recursive: bool
        :param page: page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
        :type page: int
        :param per_page: number of items per page
        :type per_page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitTreeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha',
            'recursive',
            'page',
            'per_page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        if _params.get('recursive') is not None:  # noqa: E501
            _query_params.append(('recursive', _params['recursive']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('per_page') is not None:  # noqa: E501
            _query_params.append(('per_page', _params['per_page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "GitTreeResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/trees/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_forks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[Repository]:  # noqa: E501
        ...

    @overload
    def list_forks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Repository]:  # noqa: E501
        ...

    @validate_arguments
    def list_forks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Repository], Awaitable[List[Repository]]]:  # noqa: E501
        """List a repository's forks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_forks(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Repository]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_forks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.list_forks_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def list_forks_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's forks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_forks_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Repository], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_forks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Repository]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/forks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def reject_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def reject_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def reject_repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Reject a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reject_repo_transfer(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the reject_repo_transfer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.reject_repo_transfer_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def reject_repo_transfer_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], **kwargs) -> ApiResponse:  # noqa: E501
        """Reject a repo transfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reject_repo_transfer_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_repo_transfer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Repository",
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer/reject', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_add_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to add")], body : Optional[AddCollaboratorOption] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_add_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to add")], body : Optional[AddCollaboratorOption] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_add_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to add")], body : Optional[AddCollaboratorOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Add a collaborator to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_collaborator(owner, repo, collaborator, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to add (required)
        :type collaborator: str
        :param body:
        :type body: AddCollaboratorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_add_collaborator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_add_collaborator_with_http_info(owner, repo, collaborator, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_add_collaborator_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to add")], body : Optional[AddCollaboratorOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Add a collaborator to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_collaborator_with_http_info(owner, repo, collaborator, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to add (required)
        :type collaborator: str
        :param body:
        :type body: AddCollaboratorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'collaborator',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_collaborator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['collaborator']:
            _path_params['collaborator'] = _params['collaborator']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_add_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePushMirrorOption] = None, **kwargs) -> PushMirror:  # noqa: E501
        ...

    @overload
    def repo_add_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePushMirrorOption] = None, async_req: Optional[bool]=True, **kwargs) -> PushMirror:  # noqa: E501
        ...

    @validate_arguments
    def repo_add_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePushMirrorOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[PushMirror, Awaitable[PushMirror]]:  # noqa: E501
        """add a push mirror to the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_push_mirror(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePushMirrorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PushMirror
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_add_push_mirror_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_add_push_mirror_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_add_push_mirror_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePushMirrorOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """add a push mirror to the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_push_mirror_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePushMirrorOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PushMirror, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_push_mirror" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "PushMirror",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_add_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_add_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_add_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Add a team to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_add_team_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_add_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_add_team_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> ApiResponse:  # noqa: E501
        """Add a team to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'team'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_team" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['team']:
            _path_params['team'] = _params['team']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_add_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to add")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_add_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to add")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_add_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to add")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Add a topic to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_topic(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to add (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_add_topic_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_add_topic_with_http_info(owner, repo, topic, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_add_topic_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to add")], **kwargs) -> ApiResponse:  # noqa: E501
        """Add a topic to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_add_topic_with_http_info(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to add (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'topic'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_add_topic" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['topic']:
            _path_params['topic'] = _params['topic']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics/{topic}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_apply_diff_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : UpdateFileOptions, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @overload
    def repo_apply_diff_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : UpdateFileOptions, async_req: Optional[bool]=True, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @validate_arguments
    def repo_apply_diff_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : UpdateFileOptions, async_req: Optional[bool]=None, **kwargs) -> Union[FileResponse, Awaitable[FileResponse]]:  # noqa: E501
        """Apply diff patch to repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_apply_diff_patch(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_apply_diff_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_apply_diff_patch_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_apply_diff_patch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : UpdateFileOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Apply diff patch to repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_apply_diff_patch_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_apply_diff_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "FileResponse",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/diffpatch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_cancel_scheduled_auto_merge(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_cancel_scheduled_auto_merge(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_cancel_scheduled_auto_merge(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Cancel the scheduled auto merge for the given pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_cancel_scheduled_auto_merge(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_cancel_scheduled_auto_merge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_cancel_scheduled_auto_merge_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_cancel_scheduled_auto_merge_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], **kwargs) -> ApiResponse:  # noqa: E501
        """Cancel the scheduled auto merge for the given pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_cancel_scheduled_auto_merge_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_cancel_scheduled_auto_merge" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_check_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_check_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_check_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Check if a user is a collaborator of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_collaborator(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_check_collaborator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_check_collaborator_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_check_collaborator_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], **kwargs) -> ApiResponse:  # noqa: E501
        """Check if a user is a collaborator of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_collaborator_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_check_collaborator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['collaborator']:
            _path_params['collaborator'] = _params['collaborator']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_check_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> Team:  # noqa: E501
        ...

    @overload
    def repo_check_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=True, **kwargs) -> Team:  # noqa: E501
        ...

    @validate_arguments
    def repo_check_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=None, **kwargs) -> Union[Team, Awaitable[Team]]:  # noqa: E501
        """Check if a team is assigned to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Team
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_check_team_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_check_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_check_team_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> ApiResponse:  # noqa: E501
        """Check if a team is assigned to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_check_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Team, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'team'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_check_team" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['team']:
            _path_params['team'] = _params['team']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Team",
            '404': None,
            '405': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchRepoOption] = None, **kwargs) -> Branch:  # noqa: E501
        ...

    @overload
    def repo_create_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchRepoOption] = None, async_req: Optional[bool]=True, **kwargs) -> Branch:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchRepoOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Branch, Awaitable[Branch]]:  # noqa: E501
        """Create a branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_branch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_branch_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_branch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchRepoOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a branch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_branch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Branch",
            '404': None,
            '409': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchProtectionOption] = None, **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @overload
    def repo_create_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchProtectionOption] = None, async_req: Optional[bool]=True, **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchProtectionOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[BranchProtection, Awaitable[BranchProtection]]:  # noqa: E501
        """Create a branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_protection(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_branch_protection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_branch_protection_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_branch_protection_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateBranchProtectionOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_branch_protection_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_branch_protection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "BranchProtection",
            '403': None,
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to create")], body : CreateFileOptions, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @overload
    def repo_create_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to create")], body : CreateFileOptions, async_req: Optional[bool]=True, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to create")], body : CreateFileOptions, async_req: Optional[bool]=None, **kwargs) -> Union[FileResponse, Awaitable[FileResponse]]:  # noqa: E501
        """Create a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to create (required)
        :type filepath: str
        :param body: (required)
        :type body: CreateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_file_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_file_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to create")], body : CreateFileOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to create (required)
        :type filepath: str
        :param body: (required)
        :type body: CreateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_file" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "FileResponse",
            '403': None,
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateHookOption] = None, **kwargs) -> Hook:  # noqa: E501
        ...

    @overload
    def repo_create_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateHookOption] = None, async_req: Optional[bool]=True, **kwargs) -> Hook:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateHookOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Hook, Awaitable[Hook]]:  # noqa: E501
        """Create a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_hook(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_hook_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateHookOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_hook_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Hook",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateKeyOption] = None, **kwargs) -> DeployKey:  # noqa: E501
        ...

    @overload
    def repo_create_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateKeyOption] = None, async_req: Optional[bool]=True, **kwargs) -> DeployKey:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateKeyOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[DeployKey, Awaitable[DeployKey]]:  # noqa: E501
        """Add a key to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_key(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeployKey
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_key_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_key_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateKeyOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Add a key to a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_key_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeployKey, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "DeployKey",
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePullRequestOption] = None, **kwargs) -> PullRequest:  # noqa: E501
        ...

    @overload
    def repo_create_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePullRequestOption] = None, async_req: Optional[bool]=True, **kwargs) -> PullRequest:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePullRequestOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[PullRequest, Awaitable[PullRequest]]:  # noqa: E501
        """Create a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_request(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_pull_request_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_pull_request_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_pull_request_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreatePullRequestOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_request_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreatePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "PullRequest",
            '409': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : CreatePullReviewOptions, **kwargs) -> PullReview:  # noqa: E501
        ...

    @overload
    def repo_create_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : CreatePullReviewOptions, async_req: Optional[bool]=True, **kwargs) -> PullReview:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : CreatePullReviewOptions, async_req: Optional[bool]=None, **kwargs) -> Union[PullReview, Awaitable[PullReview]]:  # noqa: E501
        """Create a review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: CreatePullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_pull_review_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : CreatePullReviewOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: CreatePullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullReview",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, **kwargs) -> List[PullReview]:  # noqa: E501
        ...

    @overload
    def repo_create_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, async_req: Optional[bool]=True, **kwargs) -> List[PullReview]:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, async_req: Optional[bool]=None, **kwargs) -> Union[List[PullReview], Awaitable[List[PullReview]]]:  # noqa: E501
        """create review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_requests(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PullReview]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_pull_review_requests_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_pull_review_requests_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_pull_review_requests_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """create review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_pull_review_requests_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PullReview], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_pull_review_requests" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "List[PullReview]",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateReleaseOption] = None, **kwargs) -> Release:  # noqa: E501
        ...

    @overload
    def repo_create_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateReleaseOption] = None, async_req: Optional[bool]=True, **kwargs) -> Release:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateReleaseOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Release, Awaitable[Release]]:  # noqa: E501
        """Create a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_release_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_release_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_release_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateReleaseOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_release" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Release",
            '404': None,
            '409': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment : Annotated[Union[StrictBytes, StrictStr], Field(..., description="attachment to upload")], name : Annotated[Optional[StrictStr], Field(description="name of the attachment")] = None, **kwargs) -> Attachment:  # noqa: E501
        ...

    @overload
    def repo_create_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment : Annotated[Union[StrictBytes, StrictStr], Field(..., description="attachment to upload")], name : Annotated[Optional[StrictStr], Field(description="name of the attachment")] = None, async_req: Optional[bool]=True, **kwargs) -> Attachment:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment : Annotated[Union[StrictBytes, StrictStr], Field(..., description="attachment to upload")], name : Annotated[Optional[StrictStr], Field(description="name of the attachment")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Attachment, Awaitable[Attachment]]:  # noqa: E501
        """Create a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_attachment(owner, repo, id, attachment, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment: attachment to upload (required)
        :type attachment: bytearray
        :param name: name of the attachment
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_release_attachment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_release_attachment_with_http_info(owner, repo, id, attachment, name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_release_attachment_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment : Annotated[Union[StrictBytes, StrictStr], Field(..., description="attachment to upload")], name : Annotated[Optional[StrictStr], Field(description="name of the attachment")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_release_attachment_with_http_info(owner, repo, id, attachment, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment: attachment to upload (required)
        :type attachment: bytearray
        :param name: name of the attachment
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'attachment',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_release_attachment" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['attachment']:
            _files['attachment'] = _params['attachment']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Attachment",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_status(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], body : Optional[CreateStatusOption] = None, **kwargs) -> CommitStatus:  # noqa: E501
        ...

    @overload
    def repo_create_status(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], body : Optional[CreateStatusOption] = None, async_req: Optional[bool]=True, **kwargs) -> CommitStatus:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_status(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], body : Optional[CreateStatusOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[CommitStatus, Awaitable[CommitStatus]]:  # noqa: E501
        """Create a commit status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_status(owner, repo, sha, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param body:
        :type body: CreateStatusOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CommitStatus
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_status_with_http_info(owner, repo, sha, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_status_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], body : Optional[CreateStatusOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a commit status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_status_with_http_info(owner, repo, sha, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param body:
        :type body: CreateStatusOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CommitStatus, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "CommitStatus",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/statuses/{sha}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateTagOption] = None, **kwargs) -> Tag:  # noqa: E501
        ...

    @overload
    def repo_create_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateTagOption] = None, async_req: Optional[bool]=True, **kwargs) -> Tag:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateTagOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Tag, Awaitable[Tag]]:  # noqa: E501
        """Create a new git tag in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_tag(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateTagOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Tag
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_tag_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateTagOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a new git tag in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_tag_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateTagOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Tag, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Tag",
            '404': None,
            '405': None,
            '409': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_create_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateWikiPageOptions] = None, **kwargs) -> WikiPage:  # noqa: E501
        ...

    @overload
    def repo_create_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateWikiPageOptions] = None, async_req: Optional[bool]=True, **kwargs) -> WikiPage:  # noqa: E501
        ...

    @validate_arguments
    def repo_create_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateWikiPageOptions] = None, async_req: Optional[bool]=None, **kwargs) -> Union[WikiPage, Awaitable[WikiPage]]:  # noqa: E501
        """Create a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_wiki_page(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_create_wiki_page_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_create_wiki_page_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_create_wiki_page_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[CreateWikiPageOptions] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_create_wiki_page_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_create_wiki_page" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "WikiPage",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/new', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to delete")], repo : Annotated[StrictStr, Field(..., description="name of the repo to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to delete")], repo : Annotated[StrictStr, Field(..., description="name of the repo to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to delete")], repo : Annotated[StrictStr, Field(..., description="name of the repo to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to delete (required)
        :type owner: str
        :param repo: name of the repo to delete (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to delete")], repo : Annotated[StrictStr, Field(..., description="name of the repo to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to delete (required)
        :type owner: str
        :param repo: name of the repo to delete (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a specific branch from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to delete (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_branch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_branch_with_http_info(owner, repo, branch, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_branch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a specific branch from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_with_http_info(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to delete (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'branch'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_branch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['branch']:
            _path_params['branch'] = _params['branch']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches/{branch}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_protection(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_branch_protection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_branch_protection_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_branch_protection_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_branch_protection_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_branch_protection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['name']:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_collaborator(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a collaborator from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_collaborator(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to delete (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_collaborator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_collaborator_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_collaborator_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a collaborator from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_collaborator_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator to delete (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_collaborator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['collaborator']:
            _path_params['collaborator'] = _params['collaborator']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to delete")], body : DeleteFileOptions, **kwargs) -> FileDeleteResponse:  # noqa: E501
        ...

    @overload
    def repo_delete_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to delete")], body : DeleteFileOptions, async_req: Optional[bool]=True, **kwargs) -> FileDeleteResponse:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to delete")], body : DeleteFileOptions, async_req: Optional[bool]=None, **kwargs) -> Union[FileDeleteResponse, Awaitable[FileDeleteResponse]]:  # noqa: E501
        """Delete a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to delete (required)
        :type filepath: str
        :param body: (required)
        :type body: DeleteFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_file_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_file_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to delete")], body : DeleteFileOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to delete (required)
        :type filepath: str
        :param body: (required)
        :type body: DeleteFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_file" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "FileDeleteResponse",
            '400': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_git_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_git_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_git_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_git_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_git_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_git_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a key from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_key(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_key_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_key_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a key from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_key_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a specific review from a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a specific review from a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_pull_review_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """cancel review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_requests(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_pull_review_requests_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_pull_review_requests_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_pull_review_requests_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], body : PullReviewRequestOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """cancel review requests for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_pull_review_requests_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param body: (required)
        :type body: PullReviewRequestOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_pull_review_requests" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of the pushMirror")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of the pushMirror")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_push_mirror(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of the pushMirror")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """deletes a push mirror from a repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_push_mirror(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of the pushMirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_push_mirror_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_push_mirror_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_push_mirror_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of the pushMirror")], **kwargs) -> ApiResponse:  # noqa: E501
        """deletes a push mirror from a repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_push_mirror_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of the pushMirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_push_mirror" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['name']:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors/{name}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_release_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_release_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_release_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_attachment(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to delete (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_release_attachment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_release_attachment_with_http_info(owner, repo, id, attachment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_release_attachment_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_attachment_with_http_info(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to delete (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release_attachment" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']

        if _params['attachment_id']:
            _path_params['attachment_id'] = _params['attachment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_by_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_release_by_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_release_by_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_release_by_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_release_by_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_release_by_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['tag']:
            _path_params['tag'] = _params['tag']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/tags/{tag}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a repository's tag by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a repository's tag by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag to delete (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['tag']:
            _path_params['tag'] = _params['tag']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags/{tag}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_team(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a team from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_team(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_team_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_team_with_http_info(owner, repo, team, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_team_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], team : Annotated[StrictStr, Field(..., description="team name")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a team from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_team_with_http_info(owner, repo, team, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param team: team name (required)
        :type team: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'team'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_team" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['team']:
            _path_params['team'] = _params['team']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams/{team}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to delete")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to delete")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_topic(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to delete")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a topic from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_topic(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to delete (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_topic_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_topic_with_http_info(owner, repo, topic, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_topic_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], topic : Annotated[StrictStr, Field(..., description="name of the topic to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a topic from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_topic_with_http_info(owner, repo, topic, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param topic: name of the topic to delete (required)
        :type topic: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'topic'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_topic" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['topic']:
            _path_params['topic'] = _params['topic']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics/{topic}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_delete_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_delete_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_delete_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_wiki_page(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_delete_wiki_page_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_delete_wiki_page_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_delete_wiki_page_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_delete_wiki_page_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_delete_wiki_page" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['page_name']:
            _path_params['pageName'] = _params['page_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : DismissPullReviewOptions, **kwargs) -> PullReview:  # noqa: E501
        ...

    @overload
    def repo_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : DismissPullReviewOptions, async_req: Optional[bool]=True, **kwargs) -> PullReview:  # noqa: E501
        ...

    @validate_arguments
    def repo_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : DismissPullReviewOptions, async_req: Optional[bool]=None, **kwargs) -> Union[PullReview, Awaitable[PullReview]]:  # noqa: E501
        """Dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_dismiss_pull_review(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: DismissPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_dismiss_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_dismiss_pull_review_with_http_info(owner, repo, index, id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_dismiss_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : DismissPullReviewOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_dismiss_pull_review_with_http_info(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: DismissPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_dismiss_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullReview",
            '403': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_download_commit_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="SHA of the commit to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def repo_download_commit_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="SHA of the commit to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def repo_download_commit_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="SHA of the commit to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """Get a commit's diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_commit_diff_or_patch(owner, repo, sha, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA of the commit to get (required)
        :type sha: str
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_download_commit_diff_or_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_download_commit_diff_or_patch_with_http_info(owner, repo, sha, diff_type, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_download_commit_diff_or_patch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="SHA of the commit to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a commit's diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_commit_diff_or_patch_with_http_info(owner, repo, sha, diff_type, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA of the commit to get (required)
        :type sha: str
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha',
            'diff_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_download_commit_diff_or_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']

        if _params['diff_type']:
            _path_params['diffType'] = _params['diff_type']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/commits/{sha}.{diffType}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_download_pull_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], binary : Annotated[Optional[StrictBool], Field(description="whether to include binary file changes. if true, the diff is applicable with `git apply`")] = None, **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def repo_download_pull_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], binary : Annotated[Optional[StrictBool], Field(description="whether to include binary file changes. if true, the diff is applicable with `git apply`")] = None, async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def repo_download_pull_diff_or_patch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], binary : Annotated[Optional[StrictBool], Field(description="whether to include binary file changes. if true, the diff is applicable with `git apply`")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """Get a pull request diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_pull_diff_or_patch(owner, repo, index, diff_type, binary, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param binary: whether to include binary file changes. if true, the diff is applicable with `git apply`
        :type binary: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_download_pull_diff_or_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_download_pull_diff_or_patch_with_http_info(owner, repo, index, diff_type, binary, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_download_pull_diff_or_patch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], diff_type : Annotated[StrictStr, Field(..., description="whether the output is diff or patch")], binary : Annotated[Optional[StrictBool], Field(description="whether to include binary file changes. if true, the diff is applicable with `git apply`")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a pull request diff or patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_download_pull_diff_or_patch_with_http_info(owner, repo, index, diff_type, binary, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param diff_type: whether the output is diff or patch (required)
        :type diff_type: str
        :param binary: whether to include binary file changes. if true, the diff is applicable with `git apply`
        :type binary: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'diff_type',
            'binary'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_download_pull_diff_or_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['diff_type']:
            _path_params['diffType'] = _params['diff_type']


        # process the query parameters
        _query_params = []
        if _params.get('binary') is not None:  # noqa: E501
            _query_params.append(('binary', _params['binary']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}.{diffType}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to edit")], repo : Annotated[StrictStr, Field(..., description="name of the repo to edit")], body : Annotated[Optional[EditRepoOption], Field(description="Properties of a repo that you can edit")] = None, **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def repo_edit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to edit")], repo : Annotated[StrictStr, Field(..., description="name of the repo to edit")], body : Annotated[Optional[EditRepoOption], Field(description="Properties of a repo that you can edit")] = None, async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to edit")], repo : Annotated[StrictStr, Field(..., description="name of the repo to edit")], body : Annotated[Optional[EditRepoOption], Field(description="Properties of a repo that you can edit")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Edit a repository's properties. Only fields that are set will be changed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to edit (required)
        :type owner: str
        :param repo: name of the repo to edit (required)
        :type repo: str
        :param body: Properties of a repo that you can edit
        :type body: EditRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to edit")], repo : Annotated[StrictStr, Field(..., description="name of the repo to edit")], body : Annotated[Optional[EditRepoOption], Field(description="Properties of a repo that you can edit")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a repository's properties. Only fields that are set will be changed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to edit (required)
        :type owner: str
        :param repo: name of the repo to edit (required)
        :type repo: str
        :param body: Properties of a repo that you can edit
        :type body: EditRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Repository",
            '403': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], body : Optional[EditBranchProtectionOption] = None, **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @overload
    def repo_edit_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], body : Optional[EditBranchProtectionOption] = None, async_req: Optional[bool]=True, **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], body : Optional[EditBranchProtectionOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[BranchProtection, Awaitable[BranchProtection]]:  # noqa: E501
        """Edit a branch protections for a repository. Only fields that are set will be changed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_branch_protection(owner, repo, name, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param body:
        :type body: EditBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_branch_protection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_branch_protection_with_http_info(owner, repo, name, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_branch_protection_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], body : Optional[EditBranchProtectionOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a branch protections for a repository. Only fields that are set will be changed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_branch_protection_with_http_info(owner, repo, name, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param body:
        :type body: EditBranchProtectionOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'name',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_branch_protection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['name']:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "BranchProtection",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], body : Optional[EditGitHookOption] = None, **kwargs) -> GitHook:  # noqa: E501
        ...

    @overload
    def repo_edit_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], body : Optional[EditGitHookOption] = None, async_req: Optional[bool]=True, **kwargs) -> GitHook:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], body : Optional[EditGitHookOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[GitHook, Awaitable[GitHook]]:  # noqa: E501
        """Edit a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_git_hook(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param body:
        :type body: EditGitHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitHook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_git_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_git_hook_with_http_info(owner, repo, id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_git_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], body : Optional[EditGitHookOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a Git hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_git_hook_with_http_info(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param body:
        :type body: EditGitHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitHook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_git_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "GitHook",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="index of the hook")], body : Optional[EditHookOption] = None, **kwargs) -> Hook:  # noqa: E501
        ...

    @overload
    def repo_edit_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="index of the hook")], body : Optional[EditHookOption] = None, async_req: Optional[bool]=True, **kwargs) -> Hook:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="index of the hook")], body : Optional[EditHookOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Hook, Awaitable[Hook]]:  # noqa: E501
        """Edit a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_hook(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: index of the hook (required)
        :type id: int
        :param body:
        :type body: EditHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_hook_with_http_info(owner, repo, id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="index of the hook")], body : Optional[EditHookOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a hook in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_hook_with_http_info(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: index of the hook (required)
        :type id: int
        :param body:
        :type body: EditHookOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Hook",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to edit")], body : Optional[EditPullRequestOption] = None, **kwargs) -> PullRequest:  # noqa: E501
        ...

    @overload
    def repo_edit_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to edit")], body : Optional[EditPullRequestOption] = None, async_req: Optional[bool]=True, **kwargs) -> PullRequest:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to edit")], body : Optional[EditPullRequestOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[PullRequest, Awaitable[PullRequest]]:  # noqa: E501
        """Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_pull_request(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to edit (required)
        :type index: int
        :param body:
        :type body: EditPullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_pull_request_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_pull_request_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_pull_request_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to edit")], body : Optional[EditPullRequestOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_pull_request_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to edit (required)
        :type index: int
        :param body:
        :type body: EditPullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_pull_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "PullRequest",
            '403': None,
            '409': None,
            '412': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to edit")], body : Optional[EditReleaseOption] = None, **kwargs) -> Release:  # noqa: E501
        ...

    @overload
    def repo_edit_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to edit")], body : Optional[EditReleaseOption] = None, async_req: Optional[bool]=True, **kwargs) -> Release:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to edit")], body : Optional[EditReleaseOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Release, Awaitable[Release]]:  # noqa: E501
        """Update a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to edit (required)
        :type id: int
        :param body:
        :type body: EditReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_release_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_release_with_http_info(owner, repo, id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_release_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to edit")], body : Optional[EditReleaseOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_with_http_info(owner, repo, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to edit (required)
        :type id: int
        :param body:
        :type body: EditReleaseOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_release" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Release",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to edit")], body : Optional[EditAttachmentOptions] = None, **kwargs) -> Attachment:  # noqa: E501
        ...

    @overload
    def repo_edit_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to edit")], body : Optional[EditAttachmentOptions] = None, async_req: Optional[bool]=True, **kwargs) -> Attachment:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to edit")], body : Optional[EditAttachmentOptions] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Attachment, Awaitable[Attachment]]:  # noqa: E501
        """Edit a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_attachment(owner, repo, id, attachment_id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to edit (required)
        :type attachment_id: int
        :param body:
        :type body: EditAttachmentOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_release_attachment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_release_attachment_with_http_info(owner, repo, id, attachment_id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_release_attachment_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to edit")], body : Optional[EditAttachmentOptions] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_release_attachment_with_http_info(owner, repo, id, attachment_id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to edit (required)
        :type attachment_id: int
        :param body:
        :type body: EditAttachmentOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_release_attachment" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']

        if _params['attachment_id']:
            _path_params['attachment_id'] = _params['attachment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Attachment",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_edit_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], body : Optional[CreateWikiPageOptions] = None, **kwargs) -> WikiPage:  # noqa: E501
        ...

    @overload
    def repo_edit_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], body : Optional[CreateWikiPageOptions] = None, async_req: Optional[bool]=True, **kwargs) -> WikiPage:  # noqa: E501
        ...

    @validate_arguments
    def repo_edit_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], body : Optional[CreateWikiPageOptions] = None, async_req: Optional[bool]=None, **kwargs) -> Union[WikiPage, Awaitable[WikiPage]]:  # noqa: E501
        """Edit a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_wiki_page(owner, repo, page_name, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_edit_wiki_page_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_edit_wiki_page_with_http_info(owner, repo, page_name, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_edit_wiki_page_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], body : Optional[CreateWikiPageOptions] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Edit a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_edit_wiki_page_with_http_info(owner, repo, page_name, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param body:
        :type body: CreateWikiPageOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page_name',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_edit_wiki_page" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['page_name']:
            _path_params['pageName'] = _params['page_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "WikiPage",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def repo_get(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def repo_get(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Get a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Repository",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_all_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[Optional[StrictStr], Field(description="SHA or branch to start listing commits from (usually 'master')")] = None, path : Annotated[Optional[StrictStr], Field(description="filepath of a file/dir")] = None, stat : Annotated[Optional[StrictBool], Field(description="include diff stats for every commit (disable for speedup, default 'true')")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results (ignored if used with 'path')")] = None, **kwargs) -> List[Commit]:  # noqa: E501
        ...

    @overload
    def repo_get_all_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[Optional[StrictStr], Field(description="SHA or branch to start listing commits from (usually 'master')")] = None, path : Annotated[Optional[StrictStr], Field(description="filepath of a file/dir")] = None, stat : Annotated[Optional[StrictBool], Field(description="include diff stats for every commit (disable for speedup, default 'true')")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results (ignored if used with 'path')")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Commit]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_all_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[Optional[StrictStr], Field(description="SHA or branch to start listing commits from (usually 'master')")] = None, path : Annotated[Optional[StrictStr], Field(description="filepath of a file/dir")] = None, stat : Annotated[Optional[StrictBool], Field(description="include diff stats for every commit (disable for speedup, default 'true')")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results (ignored if used with 'path')")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Commit], Awaitable[List[Commit]]]:  # noqa: E501
        """Get a list of all commits from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_all_commits(owner, repo, sha, path, stat, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA or branch to start listing commits from (usually 'master')
        :type sha: str
        :param path: filepath of a file/dir
        :type path: str
        :param stat: include diff stats for every commit (disable for speedup, default 'true')
        :type stat: bool
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results (ignored if used with 'path')
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Commit]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_all_commits_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_all_commits_with_http_info(owner, repo, sha, path, stat, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_all_commits_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[Optional[StrictStr], Field(description="SHA or branch to start listing commits from (usually 'master')")] = None, path : Annotated[Optional[StrictStr], Field(description="filepath of a file/dir")] = None, stat : Annotated[Optional[StrictBool], Field(description="include diff stats for every commit (disable for speedup, default 'true')")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results (ignored if used with 'path')")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a list of all commits from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_all_commits_with_http_info(owner, repo, sha, path, stat, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: SHA or branch to start listing commits from (usually 'master')
        :type sha: str
        :param path: filepath of a file/dir
        :type path: str
        :param stat: include diff stats for every commit (disable for speedup, default 'true')
        :type stat: bool
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results (ignored if used with 'path')
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Commit], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha',
            'path',
            'stat',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_all_commits" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('sha') is not None:  # noqa: E501
            _query_params.append(('sha', _params['sha']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('stat') is not None:  # noqa: E501
            _query_params.append(('stat', _params['stat']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Commit]",
            '404': None,
            '409': "APIError",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_archive(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], archive : Annotated[StrictStr, Field(..., description="the git reference for download with attached archive format (e.g. master.zip)")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_get_archive(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], archive : Annotated[StrictStr, Field(..., description="the git reference for download with attached archive format (e.g. master.zip)")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_archive(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], archive : Annotated[StrictStr, Field(..., description="the git reference for download with attached archive format (e.g. master.zip)")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Get an archive of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_archive(owner, repo, archive, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param archive: the git reference for download with attached archive format (e.g. master.zip) (required)
        :type archive: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_archive_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_archive_with_http_info(owner, repo, archive, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_archive_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], archive : Annotated[StrictStr, Field(..., description="the git reference for download with attached archive format (e.g. master.zip)")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get an archive of a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_archive_with_http_info(owner, repo, archive, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param archive: the git reference for download with attached archive format (e.g. master.zip) (required)
        :type archive: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'archive'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_archive" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['archive']:
            _path_params['archive'] = _params['archive']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/archive/{archive}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_assignees(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[User]:  # noqa: E501
        ...

    @overload
    def repo_get_assignees(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_assignees(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """Return all users that have write access and can be assigned to issues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_assignees(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_assignees_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_assignees_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_assignees_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Return all users that have write access and can be assigned to issues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_assignees_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_assignees" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/assignees', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to get")], **kwargs) -> Branch:  # noqa: E501
        ...

    @overload
    def repo_get_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to get")], async_req: Optional[bool]=True, **kwargs) -> Branch:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_branch(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Branch, Awaitable[Branch]]:  # noqa: E501
        """Retrieve a specific branch from a repository, including its effective branch protection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to get (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_branch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_branch_with_http_info(owner, repo, branch, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_branch_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], branch : Annotated[StrictStr, Field(..., description="branch to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve a specific branch from a repository, including its effective branch protection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_with_http_info(owner, repo, branch, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param branch: branch to get (required)
        :type branch: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'branch'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_branch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['branch']:
            _path_params['branch'] = _params['branch']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Branch",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches/{branch}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @overload
    def repo_get_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], async_req: Optional[bool]=True, **kwargs) -> BranchProtection:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], async_req: Optional[bool]=None, **kwargs) -> Union[BranchProtection, Awaitable[BranchProtection]]:  # noqa: E501
        """Get a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_protection(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BranchProtection
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_branch_protection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_branch_protection_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_branch_protection_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="name of protected branch")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a specific branch protection for the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_branch_protection_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: name of protected branch (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BranchProtection, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_branch_protection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['name']:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "BranchProtection",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections/{name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_by_id(self, id : Annotated[StrictInt, Field(..., description="id of the repo to get")], **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def repo_get_by_id(self, id : Annotated[StrictInt, Field(..., description="id of the repo to get")], async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_by_id(self, id : Annotated[StrictInt, Field(..., description="id of the repo to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Get a repository by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_by_id(id, async_req=True)
        >>> result = thread.get()

        :param id: id of the repo to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_by_id_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_by_id_with_http_info(self, id : Annotated[StrictInt, Field(..., description="id of the repo to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a repository by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: id of the repo to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Repository",
        }

        return self.api_client.call_api(
            '/repositories/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_combined_status_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> CombinedStatus:  # noqa: E501
        ...

    @overload
    def repo_get_combined_status_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> CombinedStatus:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_combined_status_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[CombinedStatus, Awaitable[CombinedStatus]]:  # noqa: E501
        """Get a commit's combined status, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_combined_status_by_ref(owner, repo, ref, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CombinedStatus
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_combined_status_by_ref_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_combined_status_by_ref_with_http_info(owner, repo, ref, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_combined_status_by_ref_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a commit's combined status, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_combined_status_by_ref_with_http_info(owner, repo, ref, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CombinedStatus, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'ref',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_combined_status_by_ref" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['ref']:
            _path_params['ref'] = _params['ref']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "CombinedStatus",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits/{ref}/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_contents(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the dir, file, symlink or submodule in the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ContentsResponse:  # noqa: E501
        ...

    @overload
    def repo_get_contents(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the dir, file, symlink or submodule in the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=True, **kwargs) -> ContentsResponse:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_contents(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the dir, file, symlink or submodule in the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[ContentsResponse, Awaitable[ContentsResponse]]:  # noqa: E501
        """Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the dir, file, symlink or submodule in the repo (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ContentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_contents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_contents_with_http_info(owner, repo, filepath, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_contents_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the dir, file, symlink or submodule in the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_with_http_info(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the dir, file, symlink or submodule in the repo (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ContentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_contents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "ContentsResponse",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_contents_list(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> List[ContentsResponse]:  # noqa: E501
        ...

    @overload
    def repo_get_contents_list(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=True, **kwargs) -> List[ContentsResponse]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_contents_list(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[ContentsResponse], Awaitable[List[ContentsResponse]]]:  # noqa: E501
        """Gets the metadata of all the entries of the root dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_list(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ContentsResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_contents_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_contents_list_with_http_info(owner, repo, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_contents_list_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the metadata of all the entries of the root dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_contents_list_with_http_info(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ContentsResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_contents_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[ContentsResponse]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_editor_config(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_get_editor_config(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_editor_config(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Get the EditorConfig definitions of a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_editor_config(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_editor_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_editor_config_with_http_info(owner, repo, filepath, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_editor_config_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get the EditorConfig definitions of a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_editor_config_with_http_info(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_editor_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/editorconfig/{filepath}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], **kwargs) -> GitHook:  # noqa: E501
        ...

    @overload
    def repo_get_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], async_req: Optional[bool]=True, **kwargs) -> GitHook:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_git_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], async_req: Optional[bool]=None, **kwargs) -> Union[GitHook, Awaitable[GitHook]]:  # noqa: E501
        """Get a Git hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_git_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GitHook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_git_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_git_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_git_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictStr, Field(..., description="id of the hook to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a Git hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_git_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GitHook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_git_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "GitHook",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to get")], **kwargs) -> Hook:  # noqa: E501
        ...

    @overload
    def repo_get_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to get")], async_req: Optional[bool]=True, **kwargs) -> Hook:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Hook, Awaitable[Hook]]:  # noqa: E501
        """Get a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_hook(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Hook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_hook_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a hook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_hook_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Hook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Hook",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_issue_templates(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[IssueTemplate]:  # noqa: E501
        ...

    @overload
    def repo_get_issue_templates(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[IssueTemplate]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_issue_templates(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[IssueTemplate], Awaitable[List[IssueTemplate]]]:  # noqa: E501
        """Get available issue templates for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_issue_templates(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[IssueTemplate]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_issue_templates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_issue_templates_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_issue_templates_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get available issue templates for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_issue_templates_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[IssueTemplate], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_issue_templates" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[IssueTemplate]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/issue_templates', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to get")], **kwargs) -> DeployKey:  # noqa: E501
        ...

    @overload
    def repo_get_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to get")], async_req: Optional[bool]=True, **kwargs) -> DeployKey:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to get")], async_req: Optional[bool]=None, **kwargs) -> Union[DeployKey, Awaitable[DeployKey]]:  # noqa: E501
        """Get a repository's key by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_key(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeployKey
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_key_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_key_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the key to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a repository's key by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_key_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the key to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeployKey, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "DeployKey",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_languages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> Dict[str, int]:  # noqa: E501
        ...

    @overload
    def repo_get_languages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> Dict[str, int]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_languages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[Dict[str, int], Awaitable[Dict[str, int]]]:  # noqa: E501
        """Get languages and number of bytes of code written  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_languages(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, int]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_languages_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_languages_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_languages_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get languages and number of bytes of code written  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_languages_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, int], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_languages" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, int]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/languages', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_latest_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> Release:  # noqa: E501
        ...

    @overload
    def repo_get_latest_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> Release:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_latest_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[Release, Awaitable[Release]]:  # noqa: E501
        """Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_latest_release(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_latest_release_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_latest_release_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_latest_release_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_latest_release_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_latest_release" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Release",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/latest', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_note(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], **kwargs) -> Note:  # noqa: E501
        ...

    @overload
    def repo_get_note(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], async_req: Optional[bool]=True, **kwargs) -> Note:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_note(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], async_req: Optional[bool]=None, **kwargs) -> Union[Note, Awaitable[Note]]:  # noqa: E501
        """Get a note corresponding to a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_note(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_note_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_note_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_note_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a note corresponding to a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_note_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_note" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Note",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/notes/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], **kwargs) -> PullRequest:  # noqa: E501
        ...

    @overload
    def repo_get_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], async_req: Optional[bool]=True, **kwargs) -> PullRequest:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], async_req: Optional[bool]=None, **kwargs) -> Union[PullRequest, Awaitable[PullRequest]]:  # noqa: E501
        """Get a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullRequest
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_pull_request_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_pull_request_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_pull_request_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullRequest, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullRequest",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_pull_request_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[Commit]:  # noqa: E501
        ...

    @overload
    def repo_get_pull_request_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Commit]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_pull_request_commits(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Commit], Awaitable[List[Commit]]]:  # noqa: E501
        """Get commits for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_commits(owner, repo, index, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Commit]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_pull_request_commits_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_pull_request_commits_with_http_info(owner, repo, index, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_pull_request_commits_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get commits for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_commits_with_http_info(owner, repo, index, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Commit], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request_commits" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Commit]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/commits', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_pull_request_files(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], skip_to : Annotated[Optional[StrictStr], Field(description="skip to given file")] = None, whitespace : Annotated[Optional[StrictStr], Field(description="whitespace behavior")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[ChangedFile]:  # noqa: E501
        ...

    @overload
    def repo_get_pull_request_files(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], skip_to : Annotated[Optional[StrictStr], Field(description="skip to given file")] = None, whitespace : Annotated[Optional[StrictStr], Field(description="whitespace behavior")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[ChangedFile]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_pull_request_files(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], skip_to : Annotated[Optional[StrictStr], Field(description="skip to given file")] = None, whitespace : Annotated[Optional[StrictStr], Field(description="whitespace behavior")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[ChangedFile], Awaitable[List[ChangedFile]]]:  # noqa: E501
        """Get changed files for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_files(owner, repo, index, skip_to, whitespace, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param skip_to: skip to given file
        :type skip_to: str
        :param whitespace: whitespace behavior
        :type whitespace: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ChangedFile]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_pull_request_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_pull_request_files_with_http_info(owner, repo, index, skip_to, whitespace, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_pull_request_files_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], skip_to : Annotated[Optional[StrictStr], Field(description="skip to given file")] = None, whitespace : Annotated[Optional[StrictStr], Field(description="whitespace behavior")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get changed files for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_request_files_with_http_info(owner, repo, index, skip_to, whitespace, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param skip_to: skip to given file
        :type skip_to: str
        :param whitespace: whitespace behavior
        :type whitespace: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ChangedFile], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'skip_to',
            'whitespace',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_request_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        if _params.get('skip_to') is not None:  # noqa: E501
            _query_params.append(('skip-to', _params['skip_to']))

        if _params.get('whitespace') is not None:  # noqa: E501
            _query_params.append(('whitespace', _params['whitespace'].value))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[ChangedFile]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/files', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> PullReview:  # noqa: E501
        ...

    @overload
    def repo_get_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=True, **kwargs) -> PullReview:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=None, **kwargs) -> Union[PullReview, Awaitable[PullReview]]:  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullReview",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_pull_review_comments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> List[PullReviewComment]:  # noqa: E501
        ...

    @overload
    def repo_get_pull_review_comments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=True, **kwargs) -> List[PullReviewComment]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_pull_review_comments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=None, **kwargs) -> Union[List[PullReviewComment], Awaitable[List[PullReviewComment]]]:  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_comments(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PullReviewComment]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_pull_review_comments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_pull_review_comments_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_pull_review_comments_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a specific review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_pull_review_comments_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PullReviewComment], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_pull_review_comments" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[PullReviewComment]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_push_mirror_by_remote_name(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of push mirror")], **kwargs) -> PushMirror:  # noqa: E501
        ...

    @overload
    def repo_get_push_mirror_by_remote_name(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of push mirror")], async_req: Optional[bool]=True, **kwargs) -> PushMirror:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_push_mirror_by_remote_name(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of push mirror")], async_req: Optional[bool]=None, **kwargs) -> Union[PushMirror, Awaitable[PushMirror]]:  # noqa: E501
        """Get push mirror of the repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_push_mirror_by_remote_name(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of push mirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PushMirror
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_push_mirror_by_remote_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_push_mirror_by_remote_name_with_http_info(owner, repo, name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_push_mirror_by_remote_name_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], name : Annotated[StrictStr, Field(..., description="remote name of push mirror")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get push mirror of the repository by remoteName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_push_mirror_by_remote_name_with_http_info(owner, repo, name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param name: remote name of push mirror (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PushMirror, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_push_mirror_by_remote_name" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['name']:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PushMirror",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors/{name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_raw_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_get_raw_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_raw_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Get a file from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_raw_file_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_raw_file_with_http_info(owner, repo, filepath, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_raw_file_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a file from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_with_http_info(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_raw_file" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/raw/{filepath}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_raw_file_or_lfs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_get_raw_file_or_lfs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_raw_file_or_lfs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Get a file or it's LFS object from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_or_lfs(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_raw_file_or_lfs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_raw_file_or_lfs_with_http_info(owner, repo, filepath, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_raw_file_or_lfs_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="filepath of the file to get")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag. Default the repositorys default branch (usually master)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a file or it's LFS object from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_raw_file_or_lfs_with_http_info(owner, repo, filepath, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: filepath of the file to get (required)
        :type filepath: str
        :param ref: The name of the commit/branch/tag. Default the repositorys default branch (usually master)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_raw_file_or_lfs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/media/{filepath}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to get")], **kwargs) -> Release:  # noqa: E501
        ...

    @overload
    def repo_get_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to get")], async_req: Optional[bool]=True, **kwargs) -> Release:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_release(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Release, Awaitable[Release]]:  # noqa: E501
        """Get a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_release_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_release_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_release_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a release  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release to get (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Release",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to get")], **kwargs) -> Attachment:  # noqa: E501
        ...

    @overload
    def repo_get_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to get")], async_req: Optional[bool]=True, **kwargs) -> Attachment:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_release_attachment(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Attachment, Awaitable[Attachment]]:  # noqa: E501
        """Get a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_attachment(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to get (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_release_attachment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_release_attachment_with_http_info(owner, repo, id, attachment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_release_attachment_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], attachment_id : Annotated[StrictInt, Field(..., description="id of the attachment to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a release attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_attachment_with_http_info(owner, repo, id, attachment_id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param attachment_id: id of the attachment to get (required)
        :type attachment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'attachment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release_attachment" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']

        if _params['attachment_id']:
            _path_params['attachment_id'] = _params['attachment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Attachment",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to get")], **kwargs) -> Release:  # noqa: E501
        ...

    @overload
    def repo_get_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to get")], async_req: Optional[bool]=True, **kwargs) -> Release:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_release_by_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to get")], async_req: Optional[bool]=None, **kwargs) -> Union[Release, Awaitable[Release]]:  # noqa: E501
        """Get a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_by_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to get (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Release
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_release_by_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_release_by_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_release_by_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="tag name of the release to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a release by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_release_by_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: tag name of the release to get (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Release, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_release_by_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['tag']:
            _path_params['tag'] = _params['tag']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Release",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/tags/{tag}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_repo_permissions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], **kwargs) -> RepoCollaboratorPermission:  # noqa: E501
        ...

    @overload
    def repo_get_repo_permissions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], async_req: Optional[bool]=True, **kwargs) -> RepoCollaboratorPermission:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_repo_permissions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], async_req: Optional[bool]=None, **kwargs) -> Union[RepoCollaboratorPermission, Awaitable[RepoCollaboratorPermission]]:  # noqa: E501
        """Get repository permissions for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_repo_permissions(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RepoCollaboratorPermission
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_repo_permissions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_repo_permissions_with_http_info(owner, repo, collaborator, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_repo_permissions_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], collaborator : Annotated[StrictStr, Field(..., description="username of the collaborator")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get repository permissions for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_repo_permissions_with_http_info(owner, repo, collaborator, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param collaborator: username of the collaborator (required)
        :type collaborator: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RepoCollaboratorPermission, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'collaborator'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_repo_permissions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['collaborator']:
            _path_params['collaborator'] = _params['collaborator']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "RepoCollaboratorPermission",
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators/{collaborator}/permission', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_reviewers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[User]:  # noqa: E501
        ...

    @overload
    def repo_get_reviewers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_reviewers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """Return all users that can be requested to review in this repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_reviewers(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_reviewers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_reviewers_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_reviewers_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Return all users that can be requested to review in this repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_reviewers_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_reviewers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/reviewers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_single_commit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], **kwargs) -> Commit:  # noqa: E501
        ...

    @overload
    def repo_get_single_commit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], async_req: Optional[bool]=True, **kwargs) -> Commit:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_single_commit(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], async_req: Optional[bool]=None, **kwargs) -> Union[Commit, Awaitable[Commit]]:  # noqa: E501
        """Get a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_single_commit(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Commit
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_single_commit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_single_commit_with_http_info(owner, repo, sha, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_single_commit_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="a git ref or commit sha")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a single commit from a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_single_commit_with_http_info(owner, repo, sha, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: a git ref or commit sha (required)
        :type sha: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Commit, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_single_commit" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Commit",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/commits/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag")], **kwargs) -> Tag:  # noqa: E501
        ...

    @overload
    def repo_get_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag")], async_req: Optional[bool]=True, **kwargs) -> Tag:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_tag(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag")], async_req: Optional[bool]=None, **kwargs) -> Union[Tag, Awaitable[Tag]]:  # noqa: E501
        """Get the tag of a repository by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_tag(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Tag
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_tag_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_tag_with_http_info(owner, repo, tag, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_tag_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], tag : Annotated[StrictStr, Field(..., description="name of tag")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get the tag of a repository by tag name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_tag_with_http_info(owner, repo, tag, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param tag: name of tag (required)
        :type tag: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Tag, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'tag'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_tag" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['tag']:
            _path_params['tag'] = _params['tag']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "Tag",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags/{tag}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], **kwargs) -> WikiPage:  # noqa: E501
        ...

    @overload
    def repo_get_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], async_req: Optional[bool]=True, **kwargs) -> WikiPage:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_wiki_page(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], async_req: Optional[bool]=None, **kwargs) -> Union[WikiPage, Awaitable[WikiPage]]:  # noqa: E501
        """Get a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiPage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_wiki_page_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_wiki_page_with_http_info(owner, repo, page_name, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_wiki_page_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_with_http_info(owner, repo, page_name, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiPage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_page" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['page_name']:
            _path_params['pageName'] = _params['page_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "WikiPage",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/page/{pageName}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_wiki_page_revisions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, **kwargs) -> WikiCommitList:  # noqa: E501
        ...

    @overload
    def repo_get_wiki_page_revisions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, async_req: Optional[bool]=True, **kwargs) -> WikiCommitList:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_wiki_page_revisions(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[WikiCommitList, Awaitable[WikiCommitList]]:  # noqa: E501
        """Get revisions of a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_revisions(owner, repo, page_name, page, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WikiCommitList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_wiki_page_revisions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_wiki_page_revisions_with_http_info(owner, repo, page_name, page, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_wiki_page_revisions_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page_name : Annotated[StrictStr, Field(..., description="name of the page")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get revisions of a wiki page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_page_revisions_with_http_info(owner, repo, page_name, page, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page_name: name of the page (required)
        :type page_name: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WikiCommitList, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page_name',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_page_revisions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['page_name']:
            _path_params['pageName'] = _params['page_name']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "WikiCommitList",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/revisions/{pageName}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_get_wiki_pages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[WikiPageMetaData]:  # noqa: E501
        ...

    @overload
    def repo_get_wiki_pages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[WikiPageMetaData]:  # noqa: E501
        ...

    @validate_arguments
    def repo_get_wiki_pages(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[WikiPageMetaData], Awaitable[List[WikiPageMetaData]]]:  # noqa: E501
        """Get all wiki pages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_pages(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[WikiPageMetaData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_get_wiki_pages_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_get_wiki_pages_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_get_wiki_pages_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all wiki pages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_get_wiki_pages_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[WikiPageMetaData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_get_wiki_pages" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[WikiPageMetaData]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/wiki/pages', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_all_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[Reference]:  # noqa: E501
        ...

    @overload
    def repo_list_all_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[Reference]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_all_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[Reference], Awaitable[List[Reference]]]:  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_all_git_refs(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Reference]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_all_git_refs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_all_git_refs_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_all_git_refs_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_all_git_refs_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Reference], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_all_git_refs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Reference]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/refs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[BranchProtection]:  # noqa: E501
        ...

    @overload
    def repo_list_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[BranchProtection]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_branch_protection(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[BranchProtection], Awaitable[List[BranchProtection]]]:  # noqa: E501
        """List branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branch_protection(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[BranchProtection]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_branch_protection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_branch_protection_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_branch_protection_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """List branch protections for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branch_protection_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[BranchProtection], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_branch_protection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[BranchProtection]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branch_protections', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_branches(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[Branch]:  # noqa: E501
        ...

    @overload
    def repo_list_branches(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Branch]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_branches(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Branch], Awaitable[List[Branch]]]:  # noqa: E501
        """List a repository's branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branches(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Branch]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_branches_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_branches_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_branches_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_branches_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Branch], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_branches" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Branch]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/branches', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_collaborators(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[User]:  # noqa: E501
        ...

    @overload
    def repo_list_collaborators(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_collaborators(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """List a repository's collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_collaborators(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_collaborators_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_collaborators_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_collaborators_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_collaborators_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_collaborators" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/collaborators', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_git_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[GitHook]:  # noqa: E501
        ...

    @overload
    def repo_list_git_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[GitHook]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_git_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[GitHook], Awaitable[List[GitHook]]]:  # noqa: E501
        """List the Git hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_hooks(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[GitHook]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_git_hooks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_git_hooks_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_git_hooks_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """List the Git hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_hooks_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[GitHook], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_git_hooks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[GitHook]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/git', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="part or full name of the ref")], **kwargs) -> List[Reference]:  # noqa: E501
        ...

    @overload
    def repo_list_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="part or full name of the ref")], async_req: Optional[bool]=True, **kwargs) -> List[Reference]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_git_refs(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="part or full name of the ref")], async_req: Optional[bool]=None, **kwargs) -> Union[List[Reference], Awaitable[List[Reference]]]:  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_refs(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: part or full name of the ref (required)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Reference]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_git_refs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_git_refs_with_http_info(owner, repo, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_git_refs_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="part or full name of the ref")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get specified ref or filtered repository's refs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_git_refs_with_http_info(owner, repo, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: part or full name of the ref (required)
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Reference], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_git_refs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['ref']:
            _path_params['ref'] = _params['ref']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Reference]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/git/refs/{ref}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[Hook]:  # noqa: E501
        ...

    @overload
    def repo_list_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Hook]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_hooks(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Hook], Awaitable[List[Hook]]]:  # noqa: E501
        """List the hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_hooks(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Hook]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_hooks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_hooks_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_hooks_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List the hooks in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_hooks_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Hook], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_hooks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Hook]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_keys(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], key_id : Annotated[Optional[StrictInt], Field(description="the key_id to search for")] = None, fingerprint : Annotated[Optional[StrictStr], Field(description="fingerprint of the key")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[DeployKey]:  # noqa: E501
        ...

    @overload
    def repo_list_keys(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], key_id : Annotated[Optional[StrictInt], Field(description="the key_id to search for")] = None, fingerprint : Annotated[Optional[StrictStr], Field(description="fingerprint of the key")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[DeployKey]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_keys(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], key_id : Annotated[Optional[StrictInt], Field(description="the key_id to search for")] = None, fingerprint : Annotated[Optional[StrictStr], Field(description="fingerprint of the key")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[DeployKey], Awaitable[List[DeployKey]]]:  # noqa: E501
        """List a repository's keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_keys(owner, repo, key_id, fingerprint, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param key_id: the key_id to search for
        :type key_id: int
        :param fingerprint: fingerprint of the key
        :type fingerprint: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[DeployKey]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_keys_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_keys_with_http_info(owner, repo, key_id, fingerprint, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_keys_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], key_id : Annotated[Optional[StrictInt], Field(description="the key_id to search for")] = None, fingerprint : Annotated[Optional[StrictStr], Field(description="fingerprint of the key")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_keys_with_http_info(owner, repo, key_id, fingerprint, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param key_id: the key_id to search for
        :type key_id: int
        :param fingerprint: fingerprint of the key
        :type fingerprint: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[DeployKey], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'key_id',
            'fingerprint',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_keys" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('key_id') is not None:  # noqa: E501
            _query_params.append(('key_id', _params['key_id']))

        if _params.get('fingerprint') is not None:  # noqa: E501
            _query_params.append(('fingerprint', _params['fingerprint']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[DeployKey]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_pull_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], state : Annotated[Optional[StrictStr], Field(description="State of pull request: open or closed (optional)")] = None, sort : Annotated[Optional[StrictStr], Field(description="Type of sort")] = None, milestone : Annotated[Optional[StrictInt], Field(description="ID of the milestone")] = None, labels : Annotated[Optional[conlist(StrictInt)], Field(description="Label IDs")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[PullRequest]:  # noqa: E501
        ...

    @overload
    def repo_list_pull_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], state : Annotated[Optional[StrictStr], Field(description="State of pull request: open or closed (optional)")] = None, sort : Annotated[Optional[StrictStr], Field(description="Type of sort")] = None, milestone : Annotated[Optional[StrictInt], Field(description="ID of the milestone")] = None, labels : Annotated[Optional[conlist(StrictInt)], Field(description="Label IDs")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[PullRequest]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_pull_requests(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], state : Annotated[Optional[StrictStr], Field(description="State of pull request: open or closed (optional)")] = None, sort : Annotated[Optional[StrictStr], Field(description="Type of sort")] = None, milestone : Annotated[Optional[StrictInt], Field(description="ID of the milestone")] = None, labels : Annotated[Optional[conlist(StrictInt)], Field(description="Label IDs")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[PullRequest], Awaitable[List[PullRequest]]]:  # noqa: E501
        """List a repo's pull requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_requests(owner, repo, state, sort, milestone, labels, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param state: State of pull request: open or closed (optional)
        :type state: str
        :param sort: Type of sort
        :type sort: str
        :param milestone: ID of the milestone
        :type milestone: int
        :param labels: Label IDs
        :type labels: List[int]
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PullRequest]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_pull_requests_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_pull_requests_with_http_info(owner, repo, state, sort, milestone, labels, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_pull_requests_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], state : Annotated[Optional[StrictStr], Field(description="State of pull request: open or closed (optional)")] = None, sort : Annotated[Optional[StrictStr], Field(description="Type of sort")] = None, milestone : Annotated[Optional[StrictInt], Field(description="ID of the milestone")] = None, labels : Annotated[Optional[conlist(StrictInt)], Field(description="Label IDs")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repo's pull requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_requests_with_http_info(owner, repo, state, sort, milestone, labels, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param state: State of pull request: open or closed (optional)
        :type state: str
        :param sort: Type of sort
        :type sort: str
        :param milestone: ID of the milestone
        :type milestone: int
        :param labels: Label IDs
        :type labels: List[int]
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PullRequest], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'state',
            'sort',
            'milestone',
            'labels',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_pull_requests" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state'].value))

        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort'].value))

        if _params.get('milestone') is not None:  # noqa: E501
            _query_params.append(('milestone', _params['milestone']))

        if _params.get('labels') is not None:  # noqa: E501
            _query_params.append(('labels', _params['labels']))
            _collection_formats['labels'] = 'multi'

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[PullRequest]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_pull_reviews(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[PullReview]:  # noqa: E501
        ...

    @overload
    def repo_list_pull_reviews(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[PullReview]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_pull_reviews(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[PullReview], Awaitable[List[PullReview]]]:  # noqa: E501
        """List all reviews for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_reviews(owner, repo, index, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PullReview]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_pull_reviews_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_pull_reviews_with_http_info(owner, repo, index, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_pull_reviews_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List all reviews for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_pull_reviews_with_http_info(owner, repo, index, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PullReview], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_pull_reviews" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[PullReview]",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_push_mirrors(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[PushMirror]:  # noqa: E501
        ...

    @overload
    def repo_list_push_mirrors(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[PushMirror]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_push_mirrors(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[PushMirror], Awaitable[List[PushMirror]]]:  # noqa: E501
        """Get all push mirrors of the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_push_mirrors(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PushMirror]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_push_mirrors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_push_mirrors_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_push_mirrors_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all push mirrors of the repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_push_mirrors_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PushMirror], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_push_mirrors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[PushMirror]",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_release_attachments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], **kwargs) -> List[Attachment]:  # noqa: E501
        ...

    @overload
    def repo_list_release_attachments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], async_req: Optional[bool]=True, **kwargs) -> List[Attachment]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_release_attachments(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], async_req: Optional[bool]=None, **kwargs) -> Union[List[Attachment], Awaitable[List[Attachment]]]:  # noqa: E501
        """List release's attachments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_release_attachments(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Attachment]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_release_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_release_attachments_with_http_info(owner, repo, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_release_attachments_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the release")], **kwargs) -> ApiResponse:  # noqa: E501
        """List release's attachments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_release_attachments_with_http_info(owner, repo, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the release (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Attachment], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_release_attachments" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Attachment]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases/{id}/assets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_releases(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], draft : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) drafts, if you dont have repo write access none will show")] = None, pre_release : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) pre-releases")] = None, per_page : Annotated[Optional[StrictInt], Field(description="page size of results, deprecated - use limit")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[Release]:  # noqa: E501
        ...

    @overload
    def repo_list_releases(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], draft : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) drafts, if you dont have repo write access none will show")] = None, pre_release : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) pre-releases")] = None, per_page : Annotated[Optional[StrictInt], Field(description="page size of results, deprecated - use limit")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Release]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_releases(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], draft : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) drafts, if you dont have repo write access none will show")] = None, pre_release : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) pre-releases")] = None, per_page : Annotated[Optional[StrictInt], Field(description="page size of results, deprecated - use limit")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Release], Awaitable[List[Release]]]:  # noqa: E501
        """List a repo's releases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_releases(owner, repo, draft, pre_release, per_page, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param draft: filter (exclude / include) drafts, if you dont have repo write access none will show
        :type draft: bool
        :param pre_release: filter (exclude / include) pre-releases
        :type pre_release: bool
        :param per_page: page size of results, deprecated - use limit
        :type per_page: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Release]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_releases_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_releases_with_http_info(owner, repo, draft, pre_release, per_page, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_releases_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], draft : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) drafts, if you dont have repo write access none will show")] = None, pre_release : Annotated[Optional[StrictBool], Field(description="filter (exclude / include) pre-releases")] = None, per_page : Annotated[Optional[StrictInt], Field(description="page size of results, deprecated - use limit")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repo's releases  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_releases_with_http_info(owner, repo, draft, pre_release, per_page, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param draft: filter (exclude / include) drafts, if you dont have repo write access none will show
        :type draft: bool
        :param pre_release: filter (exclude / include) pre-releases
        :type pre_release: bool
        :param per_page: page size of results, deprecated - use limit
        :type per_page: int
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Release], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'draft',
            'pre_release',
            'per_page',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_releases" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('draft') is not None:  # noqa: E501
            _query_params.append(('draft', _params['draft']))

        if _params.get('pre_release') is not None:  # noqa: E501
            _query_params.append(('pre-release', _params['pre_release']))

        if _params.get('per_page') is not None:  # noqa: E501
            _query_params.append(('per_page', _params['per_page']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Release]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/releases', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_stargazers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[User]:  # noqa: E501
        ...

    @overload
    def repo_list_stargazers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_stargazers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """List a repo's stargazers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_stargazers(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_stargazers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_stargazers_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_stargazers_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repo's stargazers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_stargazers_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_stargazers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/stargazers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_statuses(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[CommitStatus]:  # noqa: E501
        ...

    @overload
    def repo_list_statuses(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[CommitStatus]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_statuses(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[CommitStatus], Awaitable[List[CommitStatus]]]:  # noqa: E501
        """Get a commit's statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses(owner, repo, sha, sort, state, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[CommitStatus]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_statuses_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_statuses_with_http_info(owner, repo, sha, sort, state, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_statuses_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], sha : Annotated[StrictStr, Field(..., description="sha of the commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a commit's statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_with_http_info(owner, repo, sha, sort, state, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param sha: sha of the commit (required)
        :type sha: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[CommitStatus], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'sha',
            'sort',
            'state',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_statuses" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['sha']:
            _path_params['sha'] = _params['sha']


        # process the query parameters
        _query_params = []
        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort'].value))

        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state'].value))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[CommitStatus]",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/statuses/{sha}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_statuses_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[CommitStatus]:  # noqa: E501
        ...

    @overload
    def repo_list_statuses_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[CommitStatus]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_statuses_by_ref(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[CommitStatus], Awaitable[List[CommitStatus]]]:  # noqa: E501
        """Get a commit's statuses, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_by_ref(owner, repo, ref, sort, state, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[CommitStatus]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_statuses_by_ref_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_statuses_by_ref_with_http_info(owner, repo, ref, sort, state, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_statuses_by_ref_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], ref : Annotated[StrictStr, Field(..., description="name of branch/tag/commit")], sort : Annotated[Optional[StrictStr], Field(description="type of sort")] = None, state : Annotated[Optional[StrictStr], Field(description="type of state")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get a commit's statuses, by branch/tag/commit reference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_statuses_by_ref_with_http_info(owner, repo, ref, sort, state, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param ref: name of branch/tag/commit (required)
        :type ref: str
        :param sort: type of sort
        :type sort: str
        :param state: type of state
        :type state: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[CommitStatus], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'ref',
            'sort',
            'state',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_statuses_by_ref" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['ref']:
            _path_params['ref'] = _params['ref']


        # process the query parameters
        _query_params = []
        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort'].value))

        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state'].value))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[CommitStatus]",
            '400': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/commits/{ref}/statuses', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_subscribers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[User]:  # noqa: E501
        ...

    @overload
    def repo_list_subscribers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_subscribers(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """List a repo's watchers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_subscribers(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_subscribers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_subscribers_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_subscribers_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repo's watchers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_subscribers_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_subscribers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[User]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscribers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_tags(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results, default maximum page size is 50")] = None, **kwargs) -> List[Tag]:  # noqa: E501
        ...

    @overload
    def repo_list_tags(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results, default maximum page size is 50")] = None, async_req: Optional[bool]=True, **kwargs) -> List[Tag]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_tags(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results, default maximum page size is 50")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[Tag], Awaitable[List[Tag]]]:  # noqa: E501
        """List a repository's tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_tags(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results, default maximum page size is 50
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Tag]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_tags_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_tags_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_tags_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results, default maximum page size is 50")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_tags_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results, default maximum page size is 50
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Tag], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_tags" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Tag]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/tags', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_teams(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> List[Team]:  # noqa: E501
        ...

    @overload
    def repo_list_teams(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> List[Team]:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_teams(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[List[Team], Awaitable[List[Team]]]:  # noqa: E501
        """List a repository's teams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_teams(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Team]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_teams_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_teams_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_teams_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """List a repository's teams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_teams_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Team], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_teams" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[Team]",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/teams', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_list_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> TopicName:  # noqa: E501
        ...

    @overload
    def repo_list_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> TopicName:  # noqa: E501
        ...

    @validate_arguments
    def repo_list_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[TopicName, Awaitable[TopicName]]:  # noqa: E501
        """Get list of topics that a repository has  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_topics(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TopicName
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_list_topics_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_list_topics_with_http_info(owner, repo, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_list_topics_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get list of topics that a repository has  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_list_topics_with_http_info(owner, repo, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TopicName, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_list_topics" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "TopicName",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_merge_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], body : Optional[MergePullRequestOption] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_merge_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], body : Optional[MergePullRequestOption] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_merge_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], body : Optional[MergePullRequestOption] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Merge a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_merge_pull_request(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param body:
        :type body: MergePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_merge_pull_request_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_merge_pull_request_with_http_info(owner, repo, index, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_merge_pull_request_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to merge")], body : Optional[MergePullRequestOption] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Merge a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_merge_pull_request_with_http_info(owner, repo, index, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to merge (required)
        :type index: int
        :param body:
        :type body: MergePullRequestOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_merge_pull_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_migrate(self, body : Optional[MigrateRepoOptions] = None, **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def repo_migrate(self, body : Optional[MigrateRepoOptions] = None, async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def repo_migrate(self, body : Optional[MigrateRepoOptions] = None, async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Migrate a remote git repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_migrate(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: MigrateRepoOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_migrate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_migrate_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_migrate_with_http_info(self, body : Optional[MigrateRepoOptions] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Migrate a remote git repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_migrate_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: MigrateRepoOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_migrate" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '201': "Repository",
            '403': None,
            '409': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/migrate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Sync a mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_mirror_sync(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_mirror_sync_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_mirror_sync_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_mirror_sync_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], **kwargs) -> ApiResponse:  # noqa: E501
        """Sync a mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_mirror_sync_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_mirror_sync" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/mirror-sync', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_pull_request_is_merged(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_pull_request_is_merged(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_pull_request_is_merged(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Check if a pull request has been merged  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_pull_request_is_merged(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_pull_request_is_merged_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_pull_request_is_merged_with_http_info(owner, repo, index, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_pull_request_is_merged_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], **kwargs) -> ApiResponse:  # noqa: E501
        """Check if a pull request has been merged  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_pull_request_is_merged_with_http_info(owner, repo, index, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_pull_request_is_merged" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/merge', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_push_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_push_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_push_mirror_sync(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Sync all push mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_push_mirror_sync(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_push_mirror_sync_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_push_mirror_sync_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_push_mirror_sync_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to sync")], repo : Annotated[StrictStr, Field(..., description="name of the repo to sync")], **kwargs) -> ApiResponse:  # noqa: E501
        """Sync all push mirrored repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_push_mirror_sync_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to sync (required)
        :type owner: str
        :param repo: name of the repo to sync (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_push_mirror_sync" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/push_mirrors-sync', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_search(self, q : Annotated[Optional[StrictStr], Field(description="keyword")] = None, topic : Annotated[Optional[StrictBool], Field(description="Limit search to repositories with keyword as topic")] = None, include_desc : Annotated[Optional[StrictBool], Field(description="include search of keyword within repository description")] = None, uid : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id owns or contributes to")] = None, priority_owner_id : Annotated[Optional[StrictInt], Field(description="repo owner to prioritize in the results")] = None, team_id : Annotated[Optional[StrictInt], Field(description="search only for repos that belong to the given team id")] = None, starred_by : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id has starred")] = None, private : Annotated[Optional[StrictBool], Field(description="include private repositories this user has access to (defaults to true)")] = None, is_private : Annotated[Optional[StrictBool], Field(description="show only pubic, private or all repositories (defaults to all)")] = None, template : Annotated[Optional[StrictBool], Field(description="include template repositories this user has access to (defaults to true)")] = None, archived : Annotated[Optional[StrictBool], Field(description="show only archived, non-archived or all repositories (defaults to all)")] = None, mode : Annotated[Optional[StrictStr], Field(description="type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"")] = None, exclusive : Annotated[Optional[StrictBool], Field(description="if `uid` is given, search only for repos that the user owns")] = None, sort : Annotated[Optional[StrictStr], Field(description="sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"")] = None, order : Annotated[Optional[StrictStr], Field(description="sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> SearchResults:  # noqa: E501
        ...

    @overload
    def repo_search(self, q : Annotated[Optional[StrictStr], Field(description="keyword")] = None, topic : Annotated[Optional[StrictBool], Field(description="Limit search to repositories with keyword as topic")] = None, include_desc : Annotated[Optional[StrictBool], Field(description="include search of keyword within repository description")] = None, uid : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id owns or contributes to")] = None, priority_owner_id : Annotated[Optional[StrictInt], Field(description="repo owner to prioritize in the results")] = None, team_id : Annotated[Optional[StrictInt], Field(description="search only for repos that belong to the given team id")] = None, starred_by : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id has starred")] = None, private : Annotated[Optional[StrictBool], Field(description="include private repositories this user has access to (defaults to true)")] = None, is_private : Annotated[Optional[StrictBool], Field(description="show only pubic, private or all repositories (defaults to all)")] = None, template : Annotated[Optional[StrictBool], Field(description="include template repositories this user has access to (defaults to true)")] = None, archived : Annotated[Optional[StrictBool], Field(description="show only archived, non-archived or all repositories (defaults to all)")] = None, mode : Annotated[Optional[StrictStr], Field(description="type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"")] = None, exclusive : Annotated[Optional[StrictBool], Field(description="if `uid` is given, search only for repos that the user owns")] = None, sort : Annotated[Optional[StrictStr], Field(description="sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"")] = None, order : Annotated[Optional[StrictStr], Field(description="sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> SearchResults:  # noqa: E501
        ...

    @validate_arguments
    def repo_search(self, q : Annotated[Optional[StrictStr], Field(description="keyword")] = None, topic : Annotated[Optional[StrictBool], Field(description="Limit search to repositories with keyword as topic")] = None, include_desc : Annotated[Optional[StrictBool], Field(description="include search of keyword within repository description")] = None, uid : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id owns or contributes to")] = None, priority_owner_id : Annotated[Optional[StrictInt], Field(description="repo owner to prioritize in the results")] = None, team_id : Annotated[Optional[StrictInt], Field(description="search only for repos that belong to the given team id")] = None, starred_by : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id has starred")] = None, private : Annotated[Optional[StrictBool], Field(description="include private repositories this user has access to (defaults to true)")] = None, is_private : Annotated[Optional[StrictBool], Field(description="show only pubic, private or all repositories (defaults to all)")] = None, template : Annotated[Optional[StrictBool], Field(description="include template repositories this user has access to (defaults to true)")] = None, archived : Annotated[Optional[StrictBool], Field(description="show only archived, non-archived or all repositories (defaults to all)")] = None, mode : Annotated[Optional[StrictStr], Field(description="type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"")] = None, exclusive : Annotated[Optional[StrictBool], Field(description="if `uid` is given, search only for repos that the user owns")] = None, sort : Annotated[Optional[StrictStr], Field(description="sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"")] = None, order : Annotated[Optional[StrictStr], Field(description="sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[SearchResults, Awaitable[SearchResults]]:  # noqa: E501
        """Search for repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_search(q, topic, include_desc, uid, priority_owner_id, team_id, starred_by, private, is_private, template, archived, mode, exclusive, sort, order, page, limit, async_req=True)
        >>> result = thread.get()

        :param q: keyword
        :type q: str
        :param topic: Limit search to repositories with keyword as topic
        :type topic: bool
        :param include_desc: include search of keyword within repository description
        :type include_desc: bool
        :param uid: search only for repos that the user with the given id owns or contributes to
        :type uid: int
        :param priority_owner_id: repo owner to prioritize in the results
        :type priority_owner_id: int
        :param team_id: search only for repos that belong to the given team id
        :type team_id: int
        :param starred_by: search only for repos that the user with the given id has starred
        :type starred_by: int
        :param private: include private repositories this user has access to (defaults to true)
        :type private: bool
        :param is_private: show only pubic, private or all repositories (defaults to all)
        :type is_private: bool
        :param template: include template repositories this user has access to (defaults to true)
        :type template: bool
        :param archived: show only archived, non-archived or all repositories (defaults to all)
        :type archived: bool
        :param mode: type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
        :type mode: str
        :param exclusive: if `uid` is given, search only for repos that the user owns
        :type exclusive: bool
        :param sort: sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
        :type sort: str
        :param order: sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
        :type order: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchResults
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_search_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_search_with_http_info(q, topic, include_desc, uid, priority_owner_id, team_id, starred_by, private, is_private, template, archived, mode, exclusive, sort, order, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_search_with_http_info(self, q : Annotated[Optional[StrictStr], Field(description="keyword")] = None, topic : Annotated[Optional[StrictBool], Field(description="Limit search to repositories with keyword as topic")] = None, include_desc : Annotated[Optional[StrictBool], Field(description="include search of keyword within repository description")] = None, uid : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id owns or contributes to")] = None, priority_owner_id : Annotated[Optional[StrictInt], Field(description="repo owner to prioritize in the results")] = None, team_id : Annotated[Optional[StrictInt], Field(description="search only for repos that belong to the given team id")] = None, starred_by : Annotated[Optional[StrictInt], Field(description="search only for repos that the user with the given id has starred")] = None, private : Annotated[Optional[StrictBool], Field(description="include private repositories this user has access to (defaults to true)")] = None, is_private : Annotated[Optional[StrictBool], Field(description="show only pubic, private or all repositories (defaults to all)")] = None, template : Annotated[Optional[StrictBool], Field(description="include template repositories this user has access to (defaults to true)")] = None, archived : Annotated[Optional[StrictBool], Field(description="show only archived, non-archived or all repositories (defaults to all)")] = None, mode : Annotated[Optional[StrictStr], Field(description="type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"")] = None, exclusive : Annotated[Optional[StrictBool], Field(description="if `uid` is given, search only for repos that the user owns")] = None, sort : Annotated[Optional[StrictStr], Field(description="sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"")] = None, order : Annotated[Optional[StrictStr], Field(description="sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search for repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_search_with_http_info(q, topic, include_desc, uid, priority_owner_id, team_id, starred_by, private, is_private, template, archived, mode, exclusive, sort, order, page, limit, async_req=True)
        >>> result = thread.get()

        :param q: keyword
        :type q: str
        :param topic: Limit search to repositories with keyword as topic
        :type topic: bool
        :param include_desc: include search of keyword within repository description
        :type include_desc: bool
        :param uid: search only for repos that the user with the given id owns or contributes to
        :type uid: int
        :param priority_owner_id: repo owner to prioritize in the results
        :type priority_owner_id: int
        :param team_id: search only for repos that belong to the given team id
        :type team_id: int
        :param starred_by: search only for repos that the user with the given id has starred
        :type starred_by: int
        :param private: include private repositories this user has access to (defaults to true)
        :type private: bool
        :param is_private: show only pubic, private or all repositories (defaults to all)
        :type is_private: bool
        :param template: include template repositories this user has access to (defaults to true)
        :type template: bool
        :param archived: show only archived, non-archived or all repositories (defaults to all)
        :type archived: bool
        :param mode: type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
        :type mode: str
        :param exclusive: if `uid` is given, search only for repos that the user owns
        :type exclusive: bool
        :param sort: sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
        :type sort: str
        :param order: sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
        :type order: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchResults, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'q',
            'topic',
            'include_desc',
            'uid',
            'priority_owner_id',
            'team_id',
            'starred_by',
            'private',
            'is_private',
            'template',
            'archived',
            'mode',
            'exclusive',
            'sort',
            'order',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_search" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('q') is not None:  # noqa: E501
            _query_params.append(('q', _params['q']))

        if _params.get('topic') is not None:  # noqa: E501
            _query_params.append(('topic', _params['topic']))

        if _params.get('include_desc') is not None:  # noqa: E501
            _query_params.append(('includeDesc', _params['include_desc']))

        if _params.get('uid') is not None:  # noqa: E501
            _query_params.append(('uid', _params['uid']))

        if _params.get('priority_owner_id') is not None:  # noqa: E501
            _query_params.append(('priority_owner_id', _params['priority_owner_id']))

        if _params.get('team_id') is not None:  # noqa: E501
            _query_params.append(('team_id', _params['team_id']))

        if _params.get('starred_by') is not None:  # noqa: E501
            _query_params.append(('starredBy', _params['starred_by']))

        if _params.get('private') is not None:  # noqa: E501
            _query_params.append(('private', _params['private']))

        if _params.get('is_private') is not None:  # noqa: E501
            _query_params.append(('is_private', _params['is_private']))

        if _params.get('template') is not None:  # noqa: E501
            _query_params.append(('template', _params['template']))

        if _params.get('archived') is not None:  # noqa: E501
            _query_params.append(('archived', _params['archived']))

        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        if _params.get('exclusive') is not None:  # noqa: E501
            _query_params.append(('exclusive', _params['exclusive']))

        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))

        if _params.get('order') is not None:  # noqa: E501
            _query_params.append(('order', _params['order']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "SearchResults",
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/search', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_signing_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def repo_signing_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def repo_signing_key(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """Get signing-key.gpg for given repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_signing_key(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_signing_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_signing_key_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_signing_key_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get signing-key.gpg for given repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_signing_key_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_signing_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "str",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/signing-key.gpg', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_submit_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : SubmitPullReviewOptions, **kwargs) -> PullReview:  # noqa: E501
        ...

    @overload
    def repo_submit_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : SubmitPullReviewOptions, async_req: Optional[bool]=True, **kwargs) -> PullReview:  # noqa: E501
        ...

    @validate_arguments
    def repo_submit_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : SubmitPullReviewOptions, async_req: Optional[bool]=None, **kwargs) -> Union[PullReview, Awaitable[PullReview]]:  # noqa: E501
        """Submit a pending review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_submit_pull_review(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: SubmitPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_submit_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_submit_pull_review_with_http_info(owner, repo, index, id, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_submit_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], body : SubmitPullReviewOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Submit a pending review to an pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_submit_pull_review_with_http_info(owner, repo, index, id, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param body: (required)
        :type body: SubmitPullReviewOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_submit_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullReview",
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_test_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to test")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.")] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_test_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to test")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.")] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_test_hook(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to test")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Test a push webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_test_hook(owner, repo, id, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to test (required)
        :type id: int
        :param ref: The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_test_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_test_hook_with_http_info(owner, repo, id, ref, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_test_hook_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], id : Annotated[StrictInt, Field(..., description="id of the hook to test")], ref : Annotated[Optional[StrictStr], Field(description="The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Test a push webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_test_hook_with_http_info(owner, repo, id, ref, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param id: id of the hook to test (required)
        :type id: int
        :param ref: The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
        :type ref: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'id',
            'ref'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_test_hook" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('ref') is not None:  # noqa: E501
            _query_params.append(('ref', _params['ref']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/hooks/{id}/tests', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[Optional[StrictStr], Field(description="optional filter by user (available for issue managers)")] = None, since : Annotated[Optional[datetime], Field(description="Only show times updated after the given time. This is a timestamp in RFC 3339 format")] = None, before : Annotated[Optional[datetime], Field(description="Only show times updated before the given time. This is a timestamp in RFC 3339 format")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[TrackedTime]:  # noqa: E501
        ...

    @overload
    def repo_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[Optional[StrictStr], Field(description="optional filter by user (available for issue managers)")] = None, since : Annotated[Optional[datetime], Field(description="Only show times updated after the given time. This is a timestamp in RFC 3339 format")] = None, before : Annotated[Optional[datetime], Field(description="Only show times updated before the given time. This is a timestamp in RFC 3339 format")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[TrackedTime]:  # noqa: E501
        ...

    @validate_arguments
    def repo_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[Optional[StrictStr], Field(description="optional filter by user (available for issue managers)")] = None, since : Annotated[Optional[datetime], Field(description="Only show times updated after the given time. This is a timestamp in RFC 3339 format")] = None, before : Annotated[Optional[datetime], Field(description="Only show times updated before the given time. This is a timestamp in RFC 3339 format")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[TrackedTime], Awaitable[List[TrackedTime]]]:  # noqa: E501
        """List a repo's tracked times  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_tracked_times(owner, repo, user, since, before, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: optional filter by user (available for issue managers)
        :type user: str
        :param since: Only show times updated after the given time. This is a timestamp in RFC 3339 format
        :type since: datetime
        :param before: Only show times updated before the given time. This is a timestamp in RFC 3339 format
        :type before: datetime
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TrackedTime]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_tracked_times_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_tracked_times_with_http_info(owner, repo, user, since, before, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_tracked_times_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[Optional[StrictStr], Field(description="optional filter by user (available for issue managers)")] = None, since : Annotated[Optional[datetime], Field(description="Only show times updated after the given time. This is a timestamp in RFC 3339 format")] = None, before : Annotated[Optional[datetime], Field(description="Only show times updated before the given time. This is a timestamp in RFC 3339 format")] = None, page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List a repo's tracked times  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_tracked_times_with_http_info(owner, repo, user, since, before, page, limit, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: optional filter by user (available for issue managers)
        :type user: str
        :param since: Only show times updated after the given time. This is a timestamp in RFC 3339 format
        :type since: datetime
        :param before: Only show times updated before the given time. This is a timestamp in RFC 3339 format
        :type before: datetime
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TrackedTime], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'user',
            'since',
            'before',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_tracked_times" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        if _params.get('user') is not None:  # noqa: E501
            _query_params.append(('user', _params['user']))

        if _params.get('since') is not None:  # noqa: E501
            if isinstance(_params['since'], datetime):
                _query_params.append(('since', _params['since'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('since', _params['since']))

        if _params.get('before') is not None:  # noqa: E501
            if isinstance(_params['before'], datetime):
                _query_params.append(('before', _params['before'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('before', _params['before']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[TrackedTime]",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/times', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], body : Annotated[TransferRepoOption, Field(..., description="Transfer Options")], **kwargs) -> Repository:  # noqa: E501
        ...

    @overload
    def repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], body : Annotated[TransferRepoOption, Field(..., description="Transfer Options")], async_req: Optional[bool]=True, **kwargs) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def repo_transfer(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], body : Annotated[TransferRepoOption, Field(..., description="Transfer Options")], async_req: Optional[bool]=None, **kwargs) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Transfer a repo ownership  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_transfer(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param body: Transfer Options (required)
        :type body: TransferRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_transfer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_transfer_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_transfer_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo to transfer")], repo : Annotated[StrictStr, Field(..., description="name of the repo to transfer")], body : Annotated[TransferRepoOption, Field(..., description="Transfer Options")], **kwargs) -> ApiResponse:  # noqa: E501
        """Transfer a repo ownership  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_transfer_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo to transfer (required)
        :type owner: str
        :param repo: name of the repo to transfer (required)
        :type repo: str
        :param body: Transfer Options (required)
        :type body: TransferRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_transfer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '202': "Repository",
            '403': None,
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/transfer', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_un_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> PullReview:  # noqa: E501
        ...

    @overload
    def repo_un_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=True, **kwargs) -> PullReview:  # noqa: E501
        ...

    @validate_arguments
    def repo_un_dismiss_pull_review(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], async_req: Optional[bool]=None, **kwargs) -> Union[PullReview, Awaitable[PullReview]]:  # noqa: E501
        """Cancel to dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_un_dismiss_pull_review(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PullReview
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_un_dismiss_pull_review_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_un_dismiss_pull_review_with_http_info(owner, repo, index, id, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_un_dismiss_pull_review_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request")], id : Annotated[StrictInt, Field(..., description="id of the review")], **kwargs) -> ApiResponse:  # noqa: E501
        """Cancel to dismiss a review for a pull request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_un_dismiss_pull_review_with_http_info(owner, repo, index, id, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request (required)
        :type index: int
        :param id: id of the review (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PullReview, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_un_dismiss_pull_review" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "PullReview",
            '403': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_update_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to update")], body : UpdateFileOptions, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @overload
    def repo_update_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to update")], body : UpdateFileOptions, async_req: Optional[bool]=True, **kwargs) -> FileResponse:  # noqa: E501
        ...

    @validate_arguments
    def repo_update_file(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to update")], body : UpdateFileOptions, async_req: Optional[bool]=None, **kwargs) -> Union[FileResponse, Awaitable[FileResponse]]:  # noqa: E501
        """Update a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_file(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to update (required)
        :type filepath: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_update_file_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_update_file_with_http_info(owner, repo, filepath, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_update_file_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], filepath : Annotated[StrictStr, Field(..., description="path of the file to update")], body : UpdateFileOptions, **kwargs) -> ApiResponse:  # noqa: E501
        """Update a file in a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_file_with_http_info(owner, repo, filepath, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param filepath: path of the file to update (required)
        :type filepath: str
        :param body: (required)
        :type body: UpdateFileOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'filepath',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_file" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['filepath']:
            _path_params['filepath'] = _params['filepath']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "FileResponse",
            '403': None,
            '404': None,
            '422': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/contents/{filepath}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_update_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], style : Annotated[Optional[StrictStr], Field(description="how to update pull request")] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_update_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], style : Annotated[Optional[StrictStr], Field(description="how to update pull request")] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_update_pull_request(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], style : Annotated[Optional[StrictStr], Field(description="how to update pull request")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Merge PR's baseBranch into headBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_pull_request(owner, repo, index, style, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param style: how to update pull request
        :type style: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_update_pull_request_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_update_pull_request_with_http_info(owner, repo, index, style, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_update_pull_request_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], index : Annotated[StrictInt, Field(..., description="index of the pull request to get")], style : Annotated[Optional[StrictStr], Field(description="how to update pull request")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Merge PR's baseBranch into headBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_pull_request_with_http_info(owner, repo, index, style, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param index: index of the pull request to get (required)
        :type index: int
        :param style: how to update pull request
        :type style: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'index',
            'style'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_pull_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['index']:
            _path_params['index'] = _params['index']


        # process the query parameters
        _query_params = []
        if _params.get('style') is not None:  # noqa: E501
            _query_params.append(('style', _params['style'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/pulls/{index}/update', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def repo_update_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[RepoTopicOptions] = None, **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def repo_update_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[RepoTopicOptions] = None, async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def repo_update_topics(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[RepoTopicOptions] = None, async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Replace list of topics for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_topics(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: RepoTopicOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the repo_update_topics_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.repo_update_topics_with_http_info(owner, repo, body, **kwargs)  # noqa: E501

    @validate_arguments
    def repo_update_topics_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], body : Optional[RepoTopicOptions] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Replace list of topics for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.repo_update_topics_with_http_info(owner, repo, body, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param body:
        :type body: RepoTopicOptions
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repo_update_topics" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/topics', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def topic_search(self, q : Annotated[StrictStr, Field(..., description="keywords to search")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> List[TopicResponse]:  # noqa: E501
        ...

    @overload
    def topic_search(self, q : Annotated[StrictStr, Field(..., description="keywords to search")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=True, **kwargs) -> List[TopicResponse]:  # noqa: E501
        ...

    @validate_arguments
    def topic_search(self, q : Annotated[StrictStr, Field(..., description="keywords to search")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[List[TopicResponse], Awaitable[List[TopicResponse]]]:  # noqa: E501
        """search topics via keyword  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.topic_search(q, page, limit, async_req=True)
        >>> result = thread.get()

        :param q: keywords to search (required)
        :type q: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TopicResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the topic_search_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.topic_search_with_http_info(q, page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def topic_search_with_http_info(self, q : Annotated[StrictStr, Field(..., description="keywords to search")], page : Annotated[Optional[StrictInt], Field(description="page number of results to return (1-based)")] = None, limit : Annotated[Optional[StrictInt], Field(description="page size of results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """search topics via keyword  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.topic_search_with_http_info(q, page, limit, async_req=True)
        >>> result = thread.get()

        :param q: keywords to search (required)
        :type q: str
        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TopicResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'q',
            'page',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method topic_search" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('q') is not None:  # noqa: E501
            _query_params.append(('q', _params['q']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[TopicResponse]",
            '403': None,
        }

        return self.api_client.call_api(
            '/topics/search', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def user_current_check_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> WatchInfo:  # noqa: E501
        ...

    @overload
    def user_current_check_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> WatchInfo:  # noqa: E501
        ...

    @validate_arguments
    def user_current_check_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[WatchInfo, Awaitable[WatchInfo]]:  # noqa: E501
        """Check if the current user is watching a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_check_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WatchInfo
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the user_current_check_subscription_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.user_current_check_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def user_current_check_subscription_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Check if the current user is watching a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_check_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WatchInfo, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_check_subscription" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "WatchInfo",
            '404': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def user_current_delete_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> None:  # noqa: E501
        ...

    @overload
    def user_current_delete_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> None:  # noqa: E501
        ...

    @validate_arguments
    def user_current_delete_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Unwatch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_delete_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the user_current_delete_subscription_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.user_current_delete_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def user_current_delete_subscription_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Unwatch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_delete_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_delete_subscription" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def user_current_put_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> WatchInfo:  # noqa: E501
        ...

    @overload
    def user_current_put_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=True, **kwargs) -> WatchInfo:  # noqa: E501
        ...

    @validate_arguments
    def user_current_put_subscription(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], async_req: Optional[bool]=None, **kwargs) -> Union[WatchInfo, Awaitable[WatchInfo]]:  # noqa: E501
        """Watch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_put_subscription(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WatchInfo
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the user_current_put_subscription_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.user_current_put_subscription_with_http_info(owner, repo, **kwargs)  # noqa: E501

    @validate_arguments
    def user_current_put_subscription_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], **kwargs) -> ApiResponse:  # noqa: E501
        """Watch a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_current_put_subscription_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WatchInfo, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner',
            'repo'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_current_put_subscription" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/html'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "WatchInfo",
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/subscription', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def user_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[StrictStr, Field(..., description="username of user")], **kwargs) -> List[TrackedTime]:  # noqa: E501
        ...

    @overload
    def user_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[StrictStr, Field(..., description="username of user")], async_req: Optional[bool]=True, **kwargs) -> List[TrackedTime]:  # noqa: E501
        ...

    @validate_arguments
    def user_tracked_times(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[StrictStr, Field(..., description="username of user")], async_req: Optional[bool]=None, **kwargs) -> Union[List[TrackedTime], Awaitable[List[TrackedTime]]]:  # noqa: E501
        """(Deprecated) List a user's tracked times in a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_tracked_times(owner, repo, user, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: username of user (required)
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TrackedTime]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the user_tracked_times_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.user_tracked_times_with_http_info(owner, repo, user, **kwargs)  # noqa: E501

    @validate_arguments
    def user_tracked_times_with_http_info(self, owner : Annotated[StrictStr, Field(..., description="owner of the repo")], repo : Annotated[StrictStr, Field(..., description="name of the repo")], user : Annotated[StrictStr, Field(..., description="username of user")], **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) List a user's tracked times in a repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_tracked_times_with_http_info(owner, repo, user, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param user: username of user (required)
        :type user: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TrackedTime], status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn("GET /repos/{owner}/{repo}/times/{user} is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'owner',
            'repo',
            'user'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_tracked_times" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner']:
            _path_params['owner'] = _params['owner']

        if _params['repo']:
            _path_params['repo'] = _params['repo']

        if _params['user']:
            _path_params['user'] = _params['user']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['TOTPHeader', 'AuthorizationHeaderToken', 'SudoHeader', 'BasicAuth', 'AccessToken', 'SudoParam', 'Token']  # noqa: E501

        _response_types_map = {
            '200': "List[TrackedTime]",
            '400': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/repos/{owner}/{repo}/times/{user}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
